\documentclass[a4paper,12pt]{report}

\title{Broadcast Machine}
\author{Christian Bryan, Greg Opperman, Drew Wilson}

\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{hyperref}

\begin{document}

% We need title page here. It has to be formatted as per the schools specs.
\begin{titlepage}
  \topmargin 0.5in
  \headheight 0in
\begin{center}
  \begin{flushright}
Project Number: MQP-CEW-0702\\
\end{flushright}
\vspace*{40mm}
A Major Qualifying Project Report:\\
submitted to the Faculty\\
of the\\
WORCESTER POLYTECHNIC INSTITUTE\\
in partial fulfillment of the requirements for the\\
Degree of Bachelor of Science\\
By\\
\makebox[2in]{\hrulefill}\\
Christian Bryan\\
\vspace*{10mm}
\makebox[2in]{\hrulefill}\\
Greg Opperman\\
\vspace*{10mm}
\makebox[2in]{\hrulefill}\\
Drew Wilson\\
\vspace*{10mm}
\today\\
\vspace*{10mm}
\begin{flushleft}
  1. internet\\
  2. video\\
  3. php\\
\end{flushleft}
\begin{flushright}
Approved:\\
\vspace*{10mm}
\makebox[2in]{\hrulefill}\\
Professor Craig E. Wills\\
\end{flushright}
\end{center}
\end{titlepage}

\chapter*{Abstract}
% TODO: One paragraph describing the project.
% FOR: CJ
% NOTE: It's gotta be 80 words or less.
Our group came across a derelict open source web application that managed the distribution of videos.
We rebuilt the software addressing its previous problems of scalability, maintainability and usability.
Through careful evaluation and the use of popular software development techniques we successfully retooled a software package so that it could grow with its users and developers.

\chapter*{Authorship}
% TODO: Who wrote what.
% FOR: CJ
\begin{description}
  \item{Introduction}Christian Bryan
  \item{Background}Greg Opperman
  \item{Design}Greg Opperman
  \item{Implementation}Greg Opperman
  \item{System in Action}Christian Bryan
  \item{Results}Christian Bryan
  \item{Results - Feedback}Drew Wilson
  \item{Future Work}Christian Bryan
  \item{Conclusion}Christian Bryan
\end{description}

\tableofcontents

\chapter{Introduction}
% TODO: Describe the project goals and summarize the topics covered.
% FOR: CJ
This paper takes a look at the Broadcast Machine project and the work that was accomplished in the re-imagination of an unproductive piece of software.
We outline the steps that we have taken in the analysis of the problem and the development of the new package.
We guide the reader through the history of the project and its philosophical goals, the ideas that we came up with when designing the new software, how we went about implementing our ideas, and then how well our implementation performed.
There is a full walkthrough of the new software and a description of the functionality it provides.
Towards the end our group discusses the features that our group was unable to implement and how which ones we feel are necessary to the long-term success of the project.

\section{Goals}
The main goal of this project was to take the ideas that had driven the development of the first version of Broadcast Machine and create a piece of software that was more usable and maintainable.
The original code base had been abandoned because the maintainers felt that it was taking up to much time and that any further work was unlikely to be fruitful.
The first part of this project was to identify the problems that the previous developers were running into and what their underlying causes were.
Once we had interviewed the previous developers we had a better idea of what the problems were.
Based upon the developer's comments we found that it would be necessary to separate the content from the logic of the application.
The next goal was to make sure that the software was licensed in the same way as the first Broadcast Machine.
Our next step was to dive into the original Broadcast Machine code and take a look at what had been worked on previously.
(We have collected our findings on this topic in Appendix A.)


\section{Topics}
This report details the methodologies and technologies that were used in the re-imagination of the Broadcast Machine package.
We will introduce the background of the package and its original maintainers as well as outline the deficiencies that were seen to impend the development of this software.
There is a detailed discussion of the requirements that we felt existed for this package.
Each requirement has been analyzed and is discussed in detail.
Points such as the ability of the user to interact with the software and the ability of the developer to continue building on the software in the long term are both mentioned.
The philosophy and purpose behind this package is also talked about.
This is an especially important point as Broadcast Machine is built as a tool to enable people to better express themselves rather than a product designed to enrich a group.

\chapter{Background}

\section{Introduction}
% TODO: A good overview of the topics covered in the Background chapter. 
% FOR: CJ
In this section we take a look at the history of Broadcast Machine.
Our goal here is to provide the reader with a framework that will let them understand the reasons for this software's existence and the environment in which it is being built.
The importance of this software to the Participatory Culture Foundation should be noted.
As this foundation tries to promote freedom for content producers, the majority of its competitors are attempting the opposite.
Unfortunately this software has not thrived.
Due to decisions made early in the software's development and an lack of funds for its re-development Broadcast Machine has fallen by the wayside.
Our group has come to see Broadcast Machine as important player in the arena of internet video and is dedicated to ensuring that it becomes viable again.

\section{Open-Source Software}
Open source software is an important part of the movement to democratize the media and Internet. 
This common goal is what ties together PCF's mission with that of the Free Software Movement. 
The goal of the Free Software Movement is to create software to increase the freedom of the public in general.\footnote{Richard Stallman, Why Software Should Be Free \url{http://www.gnu.org/philosophy/shouldbefree.html}}
Open-Source Software accomplishes this through its transparency, which inspires community development of software, and gives users the freedom to modify the software to suit their needs.
The software is Free in the sense that there are no conditions in distributing or using it, except that users respect the freedom of the software.

Without Free software, the Internet could not exist as a democratic medium.
Proprietary (meaning closed-source) software limits what users can or can't do with it, and does not give users the ability to modify code.
With proprietary software, users cannot \"own\" software, even if they purchase it.
Instead, users pay for the privilege of using it.
Under this model, the software is less accessible and less usable (as users cannot fix problems on their own, and must rely on proprietary developer support).
On top of this, other developers cannot learn from existing code, or base new work on it without paying costly licensing fees.\footnote{Ibid} 


Open-source software aims to build a cultural community of developers who can use each other as resources, learning from existing code, and freely building upon it to create new technologies altogether.
This culture encourages technological progress in ways that competitive, closed-source software does not. 

\section{The Current State of Internet Video}
As bandwidth and storage become increasingly cheaper, the prevalence of video on the internet has sharply risen over the past few years. 
In August 2006 alone, the number of people in the U.S who streamed video 
via the internet totaled over 110 million people, which is comparable 
with the number of households that watch traditional television.\footnote{http://paul.kedrosky.com/archives/2006/10/19/fun\_with\_intern.html}
The internet has allowed independent video producers a variety of platforms by which to publish and share their work. These platforms come in one of two forms: video hosting services, which offer a centralized location from which users can upload and share videos, and Content Management Systems (CMS), where users host and maintain their own collections of videos.

\subsection{Video Hosting Services}
Video hosting services are sites that offer free hosting and sharing of video files that users upload.
These sites, such as YouTube (\url{http://youtube.com}), Blip.tv (\url{http://blip.tv}), and Myspace Videos (\url{http://vids.myspace.com}) usually also offer social networking features, such as the ability to rate and comment on videos, as well as subscribe to videos posted by friends.
The largest and most popular video hosting service is Youtube, which garners 42.94\% of all traffic to online video sites.\footnote{\url{http://www.hitwise.com/press-center/hitwiseHS2004/videosearch.php}}. 

Video hosting services offer a convenient solution for video publishers 
to share videos with little technical expertise or resources, since bandwidth and hosting costs are shouldered by the service. These sites also allow users to embed videos into their own sites, giving them creative control over how the video is displayed. However, there are several limitations to this approach. In order to keep costs down and ensure that services remain possible under heavy traffic, most video hosting sites impose limitations that affect the quality of uploaded content. Having to service over 50,000 uploads a day, YouTube transcodes all of it's videos to a lower resolution, and imposes a limitation on the length of video clips \footnote{\url{http://www.youtube.com/t/fact\_sheet}}. 

None of the major video hosting services allow adult or objectionable content.
Many sites regularly censor videos they deems inappropriate, including YouTube, who retains the right to control any and all content on its servers.
Often, videos aimed at displaying legitimate discourse or expression are lost to this censorship\footnote{\url{http://www.nytimes.com/2006/10/09/technology/09link.html?ex=1318046400&en=e311caef3c3cf222&ei=5090&partner=rssuserland&emc=rss}}.
For many publishers, the only way to ensure that their videos are presented correctly is to host them independently, using a content management system.

\subsection{Content Management Systems}

A Content Management System, or CMS, is a blanket term referring to the wide array of pre-packaged software used to manage website content. CMSes can encompass software to create wikis, forums, and several other collaborative mediums. In general, CMSes provide a simple user interface for adding, editing, and removing content, while obfuscating technical details. Using a CMS, it would be possible to build and manage an entire site without having knowledge of the underlying technologies and code. Most CMSes also offer robust theming engines, allowing users confortable with HTML and CSS to easily customize the look and feel of their site. Currently, the two most popular CMSes are Drupal and Wordpress.

\subsubsection{Drupal}
Drupal allows users to easily set up, create, and moderate blogs, forums, webpages, newsletters, and picture galleries\footnote{http://drupal.org/about}.
Written in PHP, it requires either MySQL v3.23.17 or PostgreSQL 7.2 or above\footnote{http://drupal.org/requirements}.
Thousands of popular sites use Drupal\footnote{http://DrupalSites.com}, including The Onion\footnote{ http://TheOnion.com}, OurMedia\footnote{http://www.ourmedia.org/}, and MTV's UK site\footnote{http://mtv.co.uk/}.

\subsection{Wordpress}
Wordpress one of the most popular weblogging applications, or a CMS designed specifically for posting text and image content by a small group of users.
Wordpress is PHP 4.2 and uses MySQL 3.23 as its database backend. 
It was created with the vision of creating a powerful GPL-licenced internet publishing platform based on open standards. 
The first version was released in 2001. 
Wordpress is blogging software designed to be installed on an individual's webhost, either their own computer connected to a broadband connection or a commercial webhost like Dreamhost or 1and1. There exist services such as the one at \url{http://Wordpress.com} that provide webhosting and just provide users with the a fresh install of Wordpress, but for the most part Wordpress users install the software themselves. 

Wordpress and Drupal both offer plugins for video publishing. However, there are currently no CMSes that directly address the needs of online video producers. There was a clear need for an easy to use, open-source, alternative to centralized video hosting service or complicated CMS plugins. With this in mind, the Participatory Culture Foundation (PCF), a Worcester-based non-profit, created Broadcast machine, an open-source video publishing platform.

\subsection {Broadcast Machine}
Broadcast machine is a content management system for video publishing designed to deliver videos via several different methods. Primarily, it acted as video blogging software, where users could organize videos into channels. Users could also subscribe to these channels using any RSS reader or desktop video software, such as Miro (\url{http://getmiro.com}. Broadcast Machine targeted users with little technological experience to offer a simple, easy-to-use user experience, and promoted alongside Miro (formerly Democracy Player) as part of a multi-tiered internet video platform, Broadcast Machine developed a strong following of users\footnote{A google search of the phrase \"Powered by Broadcast Machine\" returns approximately 6,700 results.}

Despite its popularity, Broadcast Machine was plagued by a number of problems due to poor architectural decisions and sloppy programming practices\footnote{PCF's bug tracker reports 67 serious, unfixed bugs as of the time of this writing}. The original Broadcast Machine stored data in one of two ways: a MySQL database or a flat-file. However, model-layer logic was poorly abstracted from the rest of the application, and small differences between the two data-layer implementations caused several irreconciliable bugs. Since the program relied on a complicated and difficult to understand architecture, tracking down and fixing these problems became nearly impossible. Poor documentation, especially concerning Broadcast Machine's complex data structures, made it especially difficult for others developers to work on the project. Due to the aforementioned issues and lack of funding, development of Broadcast Machine was abandoned in 2006, to the dismay of its dedicated users.

\chapter{Design}

\section{Introduction}
Many of Broadcast Machine's current problems stem from its poor architectural implementation. 
To prevent these problems from happening in the future, Broadcast Machine must have a carefully-planned architecture that meets several design requirements.

\section{Ease of Use}
The most important requirement for Broadcast Machine is that it be easy to use. 
Broadcast Machine's target user, people who produce videos, should not need extensive technical knowledge in order to deploy and use the program. 
Just as a devlepor has almost no knowledge of how to shoot or edit a video, we should not expect the user to have any knowledge of PHP, RSS, or any of the technologies employed. 
Without being privy to any of the inner workings of the program, the user must be able to easily and intuitively publish videos and video channels via a simple administrative interface. 
Without any information besides their web server login and password, the user should be able to set up Broadcast Machine by dropping the application into their public HTML folder. 
The program should auto-configure itself on the first-run with a few simple clicks, even if the user is completely unaware of how his or her web server is set up. 
The application must detect server configurations that may interfere with its behavior, and handle those special cases gracefully. 
Likewise, viewers with any level of computer proficiency must be able to easily browse and download videos, leave comments and feedback, and subscribe to their favorite channels.

In order to ensure the best user experience possible, the new Broadcast Machine must be stable. In addition to this, it should preserve all of the functionality of its previous incarnation, while containing none of the unpredictable behavior.

\subsection{Customizable} 
A major feature of both the former Broadcast Machine and many other CMSes is the ability to customize the look and feel of a site running the software to fit the user's own personal style. 
As before, the application must be designed with a robust theming engine so that a user with only basic HTML and CSS knowledge can easily customize the website to suit his or her needs. 
Each users' site layout, or theme, will have the potential to look drastically different from each other with only minimal modifications to CSS and template code. 
The templates must be abstracted from the functional code, so that users need not worry about damaging the code or digging deep into its inner workings when modifying the layout. 
Users should also have the ability to easily switch between layouts. 


\subsection{Extensible} 
Similarly to the presentation logic, the application logic of Broadcast Machine must be structured so that it may be easily modified and maintained by any developer with relevant skills. 
The layout of the application should appear logical and concise, with a modular architecture to encourage programmers to freely add onto Broadcast Machine's feature set in order to meet their requirements.
The architecture should be transparent and have a well-documented API so that theses developers can start extending Broadcast Machine without exhaustive knowledge of the program, but merely a solid grasp of the documented data structures and class layouts. 
When features need to be added, the developers should be able to do so while maintaining the same architectural pattern and preserving the structure of the application, by adding only a few functions or classes. 
A well-structured, extensible architecture will prevent poor programming practices by encouraging developers to replicate the design patterns used to create the foundation of the application.


\subsection{Flexible}
In addition to additions to the program, Broadcast Machine must be flexible enough so that it can be re-factored easily. 
Functionality should be abstracted and delegated so that major changes to one part of the code will not affect another. 
For example, we may decide later that we would like to use a different type of database. 
We should be able to swap out the back end without having to modify the entire application, and without significantly affecting the user experience. 
In the event that bugs occur, localizing them to a specific section of code and implementing a fix should be possible without the fix appearing hacked together or thrown in. 
Developers should not need to dig through a mountain of code before finding the section that they need to edit. 


\subsection{Compatible}
The new Broadcast Machine must work across several different platforms. 
While impossible to guarantee compatibility with all web server configurations, Broadcast Machine most work on the most common web server setups. 
This includes any Apache web server with a minimal amount of installed modules, and most major hosting services (Dreamhost, 1And1, etc). 

\chapter{Implementation}

\section{Model-View-Controller}
Based on the aforementioned design requirements, it became clear that the program architecture needed to be modularized into three separate parts. First, the presentation layer needed to be separated from program logic in order to create a theming system by which users with basic HTML and CSS knowledge could customize the style of their site. In order to make the program both extensible and flexible for developers looking to add onto or modify existing Broadcast Machine code, it became necessary to further abstract data storage to be independent of both the presentation layer and the rest of the program architecture. This separates the program into three layers, following the Model-View-Controller design pattern, or MVC\footnote{http://www.martinfowler.com/eaaDev/uiArchs.html}.


\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{./images/mvc.png}
\end{center}
\caption{Interaction between layers in MVC}
\end{figure}
In a pure Model-View-Controller architecture, all data is represented by the Model layer. The layer that the user interacts with, namely user-interface of the application, is represented in the View layer. The Controller layer represents the logic of the application, and in most cases, handles interactions between the Model and View layers. These interactions are shown in the figure above, with solid lines representing direct interactions, and dotted lines representing indirect interactions. Although in the general definition of this design pattern, the view can take user input and push it directly to the model, in most implementations it passes input to the controller for processing (input-validation), which in turn pushes the input to the model. Likewise, the view can also request data from the controller, who queries the Model layer. The query is then passed to the View for display and further user interaction.

\section{Languages and Tools}
There are several frameworks for implementing Model-View-Controller web applications, currently the most popular of which is Ruby on Rails. Ruby on Rails provides advanced features that allow automatic, rapid-prototyping of MVC applications, and object-relational mapping for controller interaction with the model layer, meaning that all data is automatically assigned to a class object based on the structure of the model layer.\footnote{http://rubyonrails.org} However, as a relatively new language, Ruby on Rails has not been widely adopted as other, more established languages. Very few basic web hosting plans support Ruby on Rails. 

To satisfy the requirement that Broadcast Machine be compatible with as many hosting and web server configurations as possible, we chose to write the application in PHP\footnote{http://php.net} running under Apache web servers\footnote{http://apache.org}. PHP is currently one of the most popular web scripting languages, while Apache is also the most prevalent web server amongst low-cost web hosts and developers running personal web servers.\footnote{http://news.netcraft.com/archives/2007/01/05/january\_2007\_web\_server\_survey.html}
Another advantage is that it is very common for PHP and Apache to be installed alongside one another. Apache's support for per-directory configurations via an .htaccess file make it very easy for users and developers to customize the environment without specialized administrator access; PHP offers object-oriented programming features that allow for the development of a MVC application that adopts many of the design principles and features of a Rails framework.

Similarly, MySQL is an open-source Database Management System (DBMS) that is one of the most widely-used Structured Query Language (SQL) implementations for data storage, alongside enterprise-level applications such as Oracle. Like PHP, MySQL comes installed by default with most hosting plans, and many hosts offer user-friendly interfaces to set up and manage databases. After a database has been created by the user with one of these tools, deploying the data layer of the application would be automated by a script. In terms of scalability, MySQL's performance rivals that of many enterprise-level DBMSes, especially when executing simple queries to create, read, update and delete small amounts of records. PHP offers several functions to interact with MySQL, making it the ideal choice for the data layer of the application.

\section{Application layout}
Using the aforementioned languages and tools, the traditional Model-View-Controller pattern was modified slightly for Broadcast Machine, in order for each layer to logically handle requests and delegate responsibilities as best as possible:

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{./images/flow.png}
\end{center}
\caption{Interaction Between Application Layers}
\end{figure}

First, Broadcast Machine receives an incoming HTTP request and invokes the dispatcher. The dispatcher is a kind of meta-controller for Broadcast Machine, that takes in a URL request and any POST data from the user, and does any work necessary before the requested controller is instantiated. The dispatcher first checks to make sure that Broadcast Machine's .htaccess file, configuration file, and database are properly set up before invoking the proper controller. If Broadcast Machine is found to be not set up, then the dispatcher automatically ignores the URL request and invokes the setup controller to initiate the proper step of the set up process. If the application is set up, then the dispatcher parses the URL request and invokes the appropriate controller. The dispatcher expects URLs in the following format:

\textbf{http://baseurl/[controller]/[param]/../[param]/} \\

If no controller is given, the dispatcher by default invokes the Channel Controller. Beyond the type of controller requested, the dispatcher delegates the responsibility of interpreting URL parameters to the invoked controller.

\section{Controllers}

All of the application logic for Broadcast Machine resides in the controller layer. Controllers are classes of objects that perform a set of related tasks. 

\subsection*{View Controllers}
View Controllers are the most common type of controller in Broadcast Machine, and are responsible for handling all of the requests that result in template rendering. All view controllers inherit some functionality and requirements from the ViewController Abstract Class. The ViewController aggregates (contains) the DatabaseController, whose specific implementation is defined by a configuration variable and automatically instantiated.\footnote{By default, Broadcast Machine uses the MySQLController.} In a similar fashion, the ViewController automatically aggregates an instance of Smarty, the default templating engine of choice.\footnote{For more information on Smarty, see the \textbf{View} section below.} ViewControllers also inherit the ability to determine permissions and assign alerts from their abstract parent. The ViewController also provides a uniform interface for invoking a template.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{./images/controllers.png}
\end{center}
\caption{ViewController API}
\end{figure}

ViewControllers are responsible for taking in an array of URL parameters\footnote{Recall that URLs are parsed by the dispatcher into an array before instantiating a ViewController}, and invoking the correct method and parameters. For example, if the ChannelController is called with the following parameters: \\

\textbf{[0] = channel, [1] = cowboys, [2] = edit} \\

The Channel Controller, in the dispatch() method, assumes that 'cowboys' is the name of the channel, and invokes the edit method with 'cowboys' as the target channel. There are five classes that implement the ViewController interface: the Setup, Channel, Video, Tag, and User Controllers. \\

\subsubsection{SetupController}
The \textbf{SetupController} is responsible for completing a Broadcast Machine installation, as well managing site  and database settings after BM has been set up. The SetupController has the following methods (corresponding URL parameters in parentheses):
\begin{description}
\item{\textbf{index (/setup/): }calls settings() by default when there are no parameters, if a user is logged in and has admin privileges.}
\item{\textbf{write\_htaccess (/setup/cleanurls/): }The first step of setup, sets up the .htaccess file for proper URL handling.}
\item{\textbf{settings (/setup/settings): } Allows an admin to set up or modify site and database settings.}
\item{\textbf{write\_bm2conf: } Writes BM's configuration file.}
\item{\textbf{firstuser (/setup/firsuser): } Allows user to create the first admin log-in.} \\
\end{description} 

\subsubsection{ChannelController}
The \textbf{ChannelController} is responsible for aggregating and managing data related to channels, or collections of videos. The ChannelController has the following methods:
\begin{description}
\item{\textbf{index (/channel/): } calls all() by default when there are no parameters.}
\item{\textbf{all (/channel/all): } Displays all channels, as well as a short list of videos in those channels and associated tags.}
\item{\textbf{add (/channel/add): } Adds a Channel to the database.}
\item{\textbf{edit (/channel/channelname/edit): } Modifies channel \textit{channelname}.}
\item{\textbf{show (/channel/channelname/): } Shows details for a channel.}
\item{\textbf{rss (/channel/channelname/rss): } Displays a channel's RSS feed.}
\item{\textbf{remove (/channel/channelname/remove): } Deletes a given channel from the database.} \\
\end{description} 

\subsubsection{VideoController}
The \textbf{VideoController} is responsible for aggregating and managing data related to videos. The VideoController has the following methods:
\begin{description}
\item{\textbf{index (/video/): } calls all() by default when there are no parameters.}
\item{\textbf{all (/video/all): } Displays all videos, as well as associated tags.}
\item{\textbf{add (/video/add): } Adds a video to the database.}
\item{\textbf{edit (/video/videoname/edit): } Modifies video \textit{videoname}.}
\item{\textbf{show (/video/videoname/): } Shows details for a video.}
\item{\textbf{download (/video/videoname/download): } Increments a video's download count and serves up the video file.}
\item{\textbf{remove (/channel/videoname/remove): } Deletes a given video from the database.} \\
\end{description} 

\subsubsection{TagController}
The \textbf{TagController} is responsible for aggregating and managing data related to tags, or categories for videos and channels. The TagController has the following methods:
\begin{description}
\item{\textbf{index (/tag/): } calls all() by default when there are no parameters.}
\item{\textbf{all (/tag/all/): } Displays all tags for channels and videos.}
\item{\textbf{show (/tag/tagname/): } Shows all videos and channels tagged with \textit{tagname}.}
\item{\textbf{rss (/tag/rss/): } Displays an RSS feed for videos tagged with \textit{tagname}.} \\
\end{description} 

\subsubsection{UserController}
The \textbf{UserController} is responsible for aggregating and managing data related to users. The UserController has the following methods:
\begin{description}
\item{\textbf{index (/user/): } calls show() for current user by default when there are no parameters, or presents a login screen if there is no active session.}
\item{\textbf{signup (/user/signup/): } Registers a user.}
\item{\textbf{login (/user/login/): } Begins a session with proper user credentials.}
\item{\textbf{all (/user/all/): } Shows all users (admin-only).}
\item{\textbf{show (/user/username/show): } Shows information for user \textit{username}.}
\item{\textbf{edit (/user/username/edit/): } Allows a user to edit their own information.}
\item{\textbf{remove (/user/username/remove/): } Allows a user or admin to remove an account.} \\
\end{description}

\subsection*{Database Controllers}
Database Controllers are controller classes that manage queries to the model layer. In implementing MySQL database support for Broadcast Machine, several abstraction layers were created to make it easy to add new DBMS support to the application.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.5]{./images/mysql.png}
\end{center}
\caption{MySQLController Inheritance Diagram}
\end{figure}

The abstract class \textbf{DatabaseController} defines the API by which all database controllers are expected to behave, witch functions to configure, connect, and disconnect from database sessions, as well as to create, read, update, and delete data, as well as to parse record sets into arrays and retrieve the unique ID of the last inserted record.

The \textbf{SQLController} extends the Database controller by providing the create, read, update, and delete functions to build and execute SQL queries for all of these functions. This abstraction provides these functions for any developer writing controllers for any other SQL implementation (such as SQLite or PostgreSQL) automatically, so long as their implementation extends the SQLController class.

Finally, the MySQL controller is a concrete implementation of the DBMS used in Broadcast Machine. It implements functions to maintain database connections by calling MySQL-specific functions in PHP, allowing other Broadcast Machine controllers to interact with the model layer.

\section{Model}
Data for Broadcast Machine can be broken down into five main entities: Channels, Videos, Tags, Users, and Settings. Settings, a group of data with no relation to the other entities, are stored in the file bm2\_conf.php, while the rest of the data is stored as a relational MySQL database (see Languages and Tools above). The entities and their relationships are shown below.
\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.45]{./images/er.png}
\end{center}
\caption{Entity-Relationship Diagram}
\end{figure}

\subsection*{Channels}
Channels used to organize videos into collections. Users can either view channels through Brodcast Machine, or subscribe to Channels via RSS or Miro. Each channel has the following attributes:
\begin{description}
\item{\textbf{title: } The name of the channel. Must be unique.}
\item{\textbf{description: } A short summary of what the channel contains.}
\item{\textbf{website\_url: } An optional link to the channel homepage.}
\item{\textbf{icon\_url: } The address of a channel icon, or logo.} \\
\end{description}
Each channel can have several videos published to it, meaning those videos will appear as part of the channel. Channels can also be tagged with descriptive keywords (see Tags).

\subsection*{Videos}
\begin{description}
\item{\textbf{title: } The name of the video. Must be unique.}
\item{\textbf{description: } A short summary of what the video is about.}
\item{\textbf{website\_url: } An optional link to the video publisher homepage.}
\item{\textbf{modified: } A timestamp of the last time a video was updated.}
\item{\textbf{release\_date: } When the video was uploaded to Broadcast Machine.}
\item{\textbf{runtime: } The length of the video, in seconds.}
\item{\textbf{file\_url: } The location of the video file.}
\item{\textbf{downloads: } The number of times the video has been downloaded.}
\item{\textbf{mime: } MIME-type of the video.\footnote{MIME is an international standard that defines what kind of content a file contains.}}
\item{\textbf{size: } Size of the video.} \\
\end{description}

\subsection*{Tags}
Tags, or categorical words that describe another entity, are represented by two database tables, channel\_tags and video\_tags. Each tag contains the unique ID of the channel or video it refers to, as well as the one-word tag itself. Tags allow channels and videos to be aggregated and organized by category or theme, allowing videos and channels to belong to several categories at once.

\subsection*{Users}
Users are members of a Broadcast Machine site, and fall into one of two categories. Administrators, or Admins, are users who manage the site and are responsible for adding, updating, and removing content. It's possible for site admins to restrict all or some videos on their site to be viewable only by registered members. Information needed to represent users is as follows:

\begin{description}
\item{\textbf{username: } The nickname that a user logs in as.}
\item{\textbf{name: } User's real-life name.}
\item{\textbf{pass: } A hash of the user's password.}
\item{\textbf{email: } User's e-mail address.}
\item{\textbf{admin: } Whether or not the user has administrative privileges.} \\
\end{description}

\subsection*{Settings}

Site settings pertain to global information about the specific Broadcast Machine installation. They typically include information needed by the dispatcher before connecting to the database or instantiating a controller. Site settings include:

\begin{description}
\item{\textbf{baseURI: } The URI of the root location of the BM installation. Used to dynamically generate links.}
\item{\textbf{baseDir: } The base directory of the BM installation. Used to properly include classes and files.}
\item{\textbf{site\_name: } The name of the site.}
\item{\textbf{site\_description: } A brief summary of the site.}
\item{\textbf{site\_iconurl: } A link to the logo of the site.} \\
\end{description}

Database connection settings are specific to the Database Management System being utilized. As such, each Database Controller is responsible for knowing which variables are set in the settings file and including them. By convention, all database settings are prefixed with 'cf' and are in the form \$cf\_varname. An example of typical database settings (in this case for the MySQLController): \\

\begin{description}
\item{\textbf{cf\_hostname: } The URI through which the database can be reached.}
\item{\textbf{cf\_database: } The name of the database.}
\item{\textbf{cf\_username: } Username needed to access database.}
\item{\textbf{cf\_password: } Password needed to access database.} \\
\end{description}

All settings, both for the Site and Database, are stored in bm2\_conf.php in Broadcast Machine's base directory. For more information on files, see \textbf{File Structure}.

\section{View}
The implementation of the presentation layer in Broadcast Machine is handled by Smarty, an open-source PHP templating engine. 
Smarty was chosen because it provides users with an easy way to create dynamic webpages without requiring that template developers deal directly with application logic or PHP, while still allowing users to customize each dynamically-generated views. In Smarty, data is assigned to templates via variables, much lke in PHP. The View Controller assigns these variables before calling a template to be rendered, and Smarty automatically inserts the variables when rendering the template, fully removing the data presented from SQL or Controller logic.
Smarty also allows for simple flow control and special variable modifiers.
These variable modifiers allow the presentation layer to retain some control over how the data is filled, while keeping a suitable amount of abstraction.
For example, they can be used to capitalize strings, alternate colors of rows, or escape special characters.
Smarty then takes in the templates for the presentation layer and compiles them into PHP. This provides the user interface, or the portion of the application that users see and interact with.

\chapter{System in Action}
\section{Overview}
This section is here to show how installation and use of Broadcast Machine works. 
We will explain and show all of the steps needed to use the software in its intended manner.
Starting off with a description of how the software handles an incoming page request and what internal steps are taken to display the correct data and then move on to a pictorial walkthrough of the data views that we have implemented.
Through these concise illustrations of the software we hope to convey the full range of Broadcast Machine's features.

\section{The Life of a Request}
When a user first launches their browser and navigates to a Broadcast Machine Installation, the browser formulates an HTTP request and sends it on to the server.
The server then processes the request and begins executing the proper piece of code.
Broadcast Machine has one piece of code that handles all of the data that is made available by the web server.
This executable is called the dispatcher.
Based on the data that the dispatcher is aware of, other parts of the system are called.
The next component that is called is a Controller.
Each controller is called based on the information in the request; If a user requests \'video\' then the Video controller is instantiated.
These controllers are passed along some of the same information that was available to the dispatcher.
The controller sees what the user is trying to request and again passes the responsibility to a function that is a part of the current controller.
The functions that make up each controller are where the real work is done.
These functions usually make a separate request to the database where data is retrieved and formatted.
Functions modify and format the data such that it is ready to be displayed.
At this point, data is passed onto a part of the system that is dedicated to putting the data into some requested form.
The data is often output in some sort of XML subset.
Broadcast Machine most often outputs to XHTML and less often RDF.
The way in which this software handles its requests is very common, many applications have used this structure to build their applications.
This methodology was dubbed \"Model, View, Controller\" by a few academic researchers in the mid-1980's and has become increasingly popular for use with web applications \footnote{\url{http://st-www.cs.uiuc.edu/users/smarch/st-docs/mvc.html}}.
A diagram of how these parts interact can be seen in the following diagram \includegraphics[width=150mm]{images/mvc.png}.
(Form more information on the architecture, take a look at the previous chapter titled \"Implementation\".)


\section{Setup}
In this section we are going to take a look at how Broadcast Machine is initially set up on a user's server.
The initial step is downloading the archive that contains the software.
In the future the software will be available through a website located at \url{http://code.google.com/p/broadcastmachine}.
After the user downloads the file, they would upload it to their server and expand it into some directory that could be accessed by a web server.

\subsection{Step One}
\includegraphics[width=150mm]{images/setup1.png}

The first screen that a user encounters when installing Broadcast Machine displays a simple greeting.
In the background, the application is detecting the current server settings and is attempting to set up as many things on its own as the server will allow.
If the server supports the Apache mod\_rewrite module the application will write an .htacccess file to the current directory.
A few settings such as the permissions on directories and the type of PHP modules installed are also detected.

\subsection{Step Two}
\includegraphics[width=150mm]{images/setup2.png}

The second setup step is where the basic information about the installation is entered.
We collect information such as the title and description of the site as well as all of the information we need to connect to the database.

\subsection{Step Three}
\includegraphics[width=150mm]{images/setup3.png}

On the third page, the user is prompted to enter in information for their first user.
This user will be the \'superuser\' and has the right to add other users or to escalate user permissions.

\subsection{Step Four}
\includegraphics[width=150mm]{images/setup4.png}

The fourth and final page is a simple confirmation that tells the user that they have successfully finished setting up the software.
From here, we provide prompts for the user to add a new channel or to take a look at their new front page.

\section{Channels}
The main component of Broadcast Machine are channels.
Channels offer a convenient way to group together videos.
Most people immediately understand the goal of a channel as a collection of thematically related content.
Our software provides an easy way for users to create, categorize and manage large amounts of video.

\subsection{All}
\includegraphics[width=150mm]{images/channelall.png}

The default display for the channels section is to show a few recent channels and a small sampling of videos from each channel.

\subsection{Show}
\includegraphics[width=150mm]{images/channelshow.png}

Each channel can be viewed individually.
This allows the user to take a more in depth look at the channel.
In this view we display all of the information we have about the channel and then display a few of the recent videos.

\subsection{RSS}
\includegraphics[width=150mm]{images/channelrss.png}

All of the channels have an associated RSS feed.
The ten most recent videos that have been posted to the channel become a part of the RSS feed.
These feeds are really important for integration with desktop clients such as Miro.
With this technology Broadcast Machine users can easily integrate their content with other services and clients.

\subsection{Add}
\includegraphics[width=150mm]{images/channeladd.png}

None of this would be of much use if the software was lacking an interface through which to add channels.
With this dialog, an administrator can add a new channel and associate a few pieces of meta data.
We currently allow titles, descriptions, tags and icons to be attached to a channel.

\subsection{Edit}
\includegraphics[width=150mm]{images/channeledit.png}

This form is very much like that of the add dialog, but this form comes pre-populated with the data from an existing channel.
Any piece of data that can be added can also be edited.

\subsection{Remove}
There is not much that we need to display for the remove action.
When an administrator goes to remove a channel, we simply alert them that their channel has been removed and then we forward them to the default channel page.

\section{Videos}
Videos are at the core of Broadcast Machine.
They are the most basic component of this application.
The video section of this software allows for all of the basic operations on a video.

\subsection{All}
\includegraphics[width=150mm]{images/videoall.png}

This view displays a number of the recent videos that have been added to the database.
This page serves as a good entry point into some of the videos that the user(s) have made available.

\subsection{Show}
\includegraphics[width=150mm]{images/videoshow.png}

The show page displays a single video and all of the information associated with it.
This page gives the user a way to view meta data and to download the video itself.
It also serves as a jumping point to the channels that the video belongs to and to the tags that have been associated with the video.

\subsection{Download}
While the download portion of each video does not have a traditional HTML view, this is the most important part of the application.
This page redirects the user to a URI where the video file can be downloaded.

\subsection{Add}
\includegraphics[width=150mm]{images/videoadd.png}

If a user is logged in and has sufficient privileges to add a video, they are presented with a form that allows them to fill in meta data.

\subsection{Edit}
\includegraphics[height=200mm]{images/videoedit.png}

This view is much like the add view. It is visually similar except for it comes populated with data associated with the video.

\subsection{Remove}
There is no discrete XHTML view associated with the remove functionality, but an alert is passed onto the administrator who removes the video.

\section{Tags}
Tags are a convenient method for users to attach information to their videos.
Broadcast Machine offers the the ability to associate a group of single meaningful words to each video and channel.
These words allow the viewer to more easily pick through the content that is being presented.
Regardless of the channel or video, a viewer can immediately key in on some specific term and be able to retrieve a stream of content relevant to that term.

\subsection{All}
\includegraphics[width=150mm]{images/tagall.png}

This is raw tag output that allows users to see a bunch of the tags currently being used by channels and videos.

\subsection{Show}
\includegraphics[width=150mm]{images/tagshow.png}

In this view we see a small sample of the channels and videos that have been associated with the given tag.

\subsection{RSS}
\includegraphics[width=150mm]{images/channelrss.png}

This view functions exactly like the previous channel RSS view that was discussed earlier.
Instead of keying in on channel data, this simply keys on tag data.

\section{Users}
The users controller allows users and administrators to manage their and other's accounts.
This controller provides authentication mechanisms and a portal to certain amounts of user information.

\subsection{Signup}
\includegraphics[width=150mm]{images/usersignup.png}

The super-user has control as to wether or not the signup pane is available to the public, but this dialog adds a simple way for users and administrators to add new accounts.
Each person is required to have a username and a password and we would prefer if they associated an email address and a name.

\subsection{Login}
\includegraphics[width=150mm]{images/userlogin.png}

At this page the current user is prompted for their credentials.
Their username and password are requested and then authenticated.
If the credentials are correct, the user is marked as \'trusted\'.
If not, then no mark is associated.

\subsection{Logout}
This is another piece of important functionality that is without an XHTML view.
The function is simple, it erases all of the session data currently set and alerts the user that they have logged out.
The user is then redirected to the home page.

\subsection{Show}
\includegraphics[width=150mm]{images/usershow.png}

At this point users are given the chance to view a single user and all of the data that is associated with that user.

\chapter{Results}

\section{Overview}

\section{Unit testing}

\section{Feedback}

\subsection{Mike Benedetti}

On February 23, 2008 we met with Mike Benedetti, the webmaster from Worcester's Community Cable Access (WCCA) Channel 
13. Mike is a part of the internet video community, as a member of Worcester Indymedia and as an independent journalist. Mike publishes the Snow Ghost Community Show\footnote{http://www.wccatv.com/snowghost} online for WCCA.
We introduced Mike to Broadcast Machine, and asked for some feedback on the user experience.
Our major goal was to determine if his expectations for the interface meshed well with the existing feel of the application.
Because of his experience with internet video publishing, he was in a unique position to provide feedback on Broadcast Machine.

WCCA has recently begun putting all of their video content online, using Drupal with a number of modules as their content management system. 
Mike explainedthat there were a number of drawbacks with his current setup. 
Mike stressed that there was not yet a one-stop video content management system, although he did point out that there 
exist plugins and modules for existing CMS's that transforms them into a make-shift video CMS. 

We started our discussion by having Mike describe WCCA's video publishing process:

\begin{enumerate}
\item A content producer records a show in their studio. 
\item The show is edited and cut down to fit the time-slot.
\item The show is aired on the cable station. 
\item Mike uploads a high-quality copy of the video is to archive.org. He must input various attributes of the video, including the title, text description, director, producer, production company, keywords and information about the audio and visuals. 
\item Archive.org's servers then convert the video into a number of file sizes and formats and make the files publicly available.
\item Mike embeds a lower-quality version of the file in a post using Drupal. Mike must re-enter all of the video attributes at this point.
\item The video is posted to the WCCA site and Drupal handles adding an entry to the video rss file.
\end{enumerate}

After we talked with Mike about his setup, we opened up a browser and had him explore Broadcast Machine. At this point we 
asked him to follow links and describe what his exceptions for the pages were and compare his expectations to the 
content of our pages. 
It was valuable to hear that Mike's expectations for the views were somewhat different than what we had. 
There were a few specific UI suggestions that he had, but most important suggestion on how to visually present our data.
More broadly, Mike gave us a feel for where broadcast machine fits into the landscape of Internet video publishing. 

He seemed to be hopeful about our project and it might be a good fit for his needs.

Mike explained that it made more sense to him to have the videos appear in a more traditional blog layout, with clear 
differentiation between posts, and with a publish date clearly indicated. 
He also pointed out that we needed to make it clear that the RSS feeds were video feeds that could be used with 
programs like Miro. To bring attention to this feature, we moved icons for RSS and Miro subscription links to be more prominent on pages where feeds are available, and also updated several templates to clearly differentiate between video posts with better-presented information. Mike indicated that he was confused about what data was in the RSS feeds, based on their placement. We discovered that it needed to be made more clear that the video feeds had enclosures, and moved the RSS icons to a location on the page that more clearly indicated their content. In accordance with Mike's suggestions, we also edited templates for consistency in ordering videos and channels.

As was mentioned earlier, WCCA uses archive.org as their long-term storage. 
Mike suggested that Broadcast Machine would be a more appealing piece of software if, in a future release, it 
incorporated an easy mechanism for external storage solutions. 
We looked at WCCA's account and found that there is an XML API provided for archive.org to integrate with external 
software. With their API in place, implementing scraping archive.org's XML data would be an easy task for future releases. Mike also suggested integration with several other storage providers, including Amazon's S3 service. While certainly a good idea for the future, implementing robust integration with several different services is a major task, and was outside the scope of this project's time constraints.

Mike recalled that the previous version of Broadcast Machine was based on BlogTorrent, an implementation of the BitTorrent transfer protocol for blogs. 
However, he also noted that he was unable to get BitTorrent support to work with previous installs of Broadcast Machine, an experience that several other users of the earlier BM often shared. 
Mike suggested we add some sort of BitTorrent integration.
While the current Broadcast Machine does allow users to upload or link to .torrent files and share them, we identified the need for an integrated BitTorrent server in order to automatically seed, or upload videos. We had previously considered adding this feature. However, we found that most hosting providers do not allow server-side sharing of torrents in any regard. Due to this constraint, we decided to abandon implementation of this feature, but are now reconsidering it for advanced users running their own web servers.

Meeting with Mike Benedetti gave us a good perspective on how video publishers would react to Broadcast Machine. 
We did not incorporate all of his suggestions, but we did make a number of changes based on his ideas. 
It was encouraging to hear that Broadcast Machine could grow to fill a vital niche in the video publishing field, and might even be utilized by WCCA in the future.

\chapter{Future Work}
While this project has done much work to make Broadcast Machine a piece of modern video management software, there are many features that should be implemented in order to provide the best user experience possible.
Fortunately, Broadcast Machine will live on longer than this current project.
Our group hopes to continue to cultivate this application as an open-source project after this MQP.
Opening this code-base to a community and encouraging all types of hobbyists to contribute will allow us to implement a few of the features that we think would be beneficial to the software.

One of the first features that this project did not implement was BitTorrent support.
The initial version of Broadcast Machine was hailed as being one of easiest ways to distribute content via this de-centralized network.
We think that this feature is still very important to goals that Broadcast Machine tries to accomplish.
The ability to save bandwidth and provide free redundancy is immensely important.
These features should be trivial to implement as most of the code for these features is available in the initial version of the software.

With the rise of online video, many content providers have decided to make their video viewable online through the use of a Flash applet.
The use of this embed-able program allows the provider to make video viewable on almost any computer on any platform.
If the user has encoded their video using the FLV codec or the H.264 codec, a well-designed SWF can provide the playback interface.
While this interface can only be provided through the use of a closed-source application framework, it is perhaps the most usable method for providing a video player.
Fortunately, with the use of file-type detection and the adaptation of open-source Flash applications we feel that this feature would be important to provide.

The next feature that would be most beneficial to the user-base would be robust internationalization support.
The computer world largely deals with English as the default language in which to implement software, the majority of the world does not function in English.
There are a large number of users who would benefit through the existence of a multi-language framework.
The ability for Broadcast Machine to be translated into multiple languages would be a tremendous boon to users across the world and would increase the number of people that our package would be immediately usable to.
This feature would be relatively easy to implement as well.
Because of the architectural decisions that we have made, the translation would only take a few hours to a native speaker of any language.
Given that we are able to find people willing to volunteer for this job, this feature would be of great benefit.

The last feature that our team thought useful was AJAX support.
AJAX has become popular for use in web applications lately as it allows for asynchronous functions that are often found in desktop applications.
Through the use of these methods we would be able to allow administrators to edit the content on their pages without having to refresh the page.
All of the necessary information changes hands in the background.
This feature would be a bit harder to implement.
Many changes would be needed to properly interpret the new flow of information, and integrating these client-side programs would likely take a long time.
The benefit would be increased ease of use; Broadcast Machine would \'feel\' much like a desktop application.

All of these features are certainly within reach.
The benefits to the users afforded by their implementation versus the effort required is certainly reasonable.
Hopefully Broadcast Machine sees these features added to its code base in the coming months.
Its life as an open source project and the addition of other contributors should speed the addition of these features that we have not had time to add.
 
\chapter{Conclusion}

\appendix
\chapter{Former Broadcast Machine Documentation}

\section{Data Model}


\subsection{Instances}
The instance table was used to prevent two versions of Broadcast Machine from using the same database. In the previous version of Broadcast Machine, if more than one site was using the same database, a warning was displayed on the main page of the administrative interface. The table consists of a hash string of the hostname (id), and a timestamp for when the instance was created (time). 


\subsection{Stats}
The stats table allowed the user to keep track of the number of user downloads for each video. It contained a unique hash of the filename (id), and an integer for the number of downloads (downloads). The table has a one-to-one relationship with files.


\subsection{Channels}
The channels table was used to store metadata about specific RSS video feeds, or channels. This data was used to generate the channel view and RSS feeds for each channel, which is how most users interact with the application. 
%Show a screenshot of the channel view, perhaps?
It contained a unique integer identifier (ID, the primary key), A text explanation of the channel (description), and integer number for when the channel was made (Created), a text title for the channel (name), fields for URLs of linked icons, libraries, and the channel's main website (Icon, LibraryURL, and WebURL, respectively), a field to designate the publisher (Publisher). In addition to this, it has several tiny int values that served as settings flags, with 0 being false, and the default value, and 1 being true. This includes OpenPublish, RequireLogin, and NotPublic. OpenPublish allowed administrators to designate whether or not non-administrative users were allowed to publish videos to a channel. RequireLogin was used to determine whether or not users must be logged in to view the channel. If NotPublic was set, the channel itself would be hidden from anonymous users.
It also contained CSSURL, which would store a link to an external style sheet to be used in rendering the channel page.


The channel\_options table keeps track of the individual settings for a given channel. Each record in the table contains an integer reference to the channel it refers to (ID). Several boolean flags determined which information about a video would be shown on the channel view: Creator, Description, Filesize, Keywords, Length, Published, Thumbnail, Title, Torrent, URL. There is also a tiny int field called SubscribeOptions, whose default value is 7. This value determines which subscription links will be made available to users (RSS, Democracy, and iTunes, which requires direct URLs to be enabled in the site settings). In this field, RSS is represented by a value of 1, Democracy by a value of 2, and iTunes by a value of 4. Adding together the values of available subscription links determines the field's value. For example, A value of 7 means that all links are available for use, while a value of 1 would mean that only RSS could be used. A value of 6 would mean that iTunes and Democracy subscription links should be made available. 


The channel\_files table records associations between the channels table and the files table (see below). In other words, it allows Broadcast Machine to keep track of which files belong to which channel, which is essential to the channel view and RSS feeds. It contains a reference to the channel in question (channel\_id), the hash of the file (hash), and integer timestamp (thetime). The primary key is channel\_id and hash, meaning that there can't be more than one record for any channel and file pair.


The channel\_sections table allows channels to be split up into several subsections. From experience, this seems to be widely unused by BM's user base, and is also not implemented in the RSS view. As such, it may be deprecated. The table itself contains an integer reference to the channel the record refers to (channel\_id) and the name of the section (Name). The table also shares a one-to-one relationship with the channels table.


Like channel\_files, the section\_files table tracks which files are associated with which sections. The table contains a reference to channel\_id, a reference to the name of the section, and the hash of the file. The combination of those three fields are a primary key and must be unique.


\subsection{Videos}
The table for storing video information is the files table. This information is used to render the details page for each individual video. The files table contains a unique integer identifier for each video (ID), an ineger for when the file was created (Created), the name of the file (FileName), the name of the person who created the channel (Creator), a text summary of the file (Description), a title (Title), an optional link to a transcript for the hearing-disabled (transcript), a link to a website for more information(Webpage), an optional donation code (donation\_id), boolean flags for Excerpt, Explicit, ignore\_mimetype, and External properties, and URL, in case the file was linked to externally. It also contains a link to an image thumnail of the video (Image), name and URL of the license used to distribute the video (LicenseName, LicenseURL), the MIME-type of the file (Mimetype), an integer for the date published (Publishdate), and the date of the video release via three fields: ReleaseDay, ReleaseMonth, and ReleaseYear (all are integers). Also included is a short string called Rights, which is slightly redundant due to the License field. 


Records of people who have contributed to the making of a video were stored in the file\_people table. This allowed administrators to include conprehensive credits for anyone working on the video. The table contained an identifier for which video the credit refers to (ID), their name (name), and what they were credited for (role). The combination of these three values were required to be unique as a primary key.


\"Tags\", or categories to classify videos by, were stored in the file\_keywords table. This allowed administrators to classify videos by category, so that users could browse videos in that category across many channels. This table contained an ID reference to the video, and then the keyword that the video would be tagged by. Although one video may have had many tags, no video could have two identical tags.


\subsection{Donations}
The donation table stores information on how users can contribute to the makers of a video. This allowed the generation of donation links to be displayed alongside a video in the video view, as well as from within Democracy and the RSS feed for the channel. Users could use these links to contribute to the makers of the video. Each donation record had a unique ID, an e-mail address (email), a short description (title), and a longer text donation pitch (text). Putting this information in its own table allowed publishers to frequently associate videos with the same donation info, as this info rarely changed. 


The donation\_files table links together donation info with video info. The table conatined the id of the donation info, as well as the hash id of the video (hash). Each video could only be linked to one set of donation information, so id and hash are both primary keys.


\subsection{Users}
The user table contained information about registered users. This table contained an alias for each user (Username), the user's real name (Name), their encrypted password (Hash), their e-mail address (Email), when they registered (Created), and their permissions information (IsAdmin, IsPending). 


The newusers table tracked only those users who have not verified their account. This allowed functionality to prevent scripted bots to spam Broadcast Machine installations with open registration, by requiring that all users verify their e-mail address. The table included a filehash, their password (Hash), their e- mail address (email), IsAdmin, and when they created the account (Created).


\subsection{Settings}
Settings for the website itself was stored in a B-Encoded flat file. This allowed users to customize site security features, as well as which features they wanted to use. This is also where essential information such as database connection settings were stored. These fields include whether or not new user registration was allowed (AllowRegistration), whether or not they required approval (RequireRegApproval), whether or not they needed to verify their account (RequireRegAuth), whether or not users could upload or download anonymously (UploadRegRequired and DownloadRegRequired, respectively), the default channel (DefaultChannel), whether the site has channels that anyone could modify (HasOpenChannels), their current site layout (theme), title of the site, the site description, an image associated with the site, the base url for the site (baseurl), database connection settings (mysql\_prefix, mysql\_host, mysql\_username, mysql\_password, mysql\_database, and mysql\_verified), and BitTorrent sharing settings (Ping, sharing\_enable, sharing\_auto, sharing\_python, sharing\_actual\_python, minport, maxport).

\chapter{Disorganized Mess}
\section{New Model}
%This will be changed and updated as the new schema comes along further
%Needs: People should be relational!
Broadcast Machine must keep track of several pieces of information pertaining to its entities (channels, files, etc.).
A comprehensive list of the data follows (entity relationships highlighted in bold):


\subsection{Data associated with Channels}
\begin{description}
\item[Channel ID] An arbitrary, unique number to identify the channel and  associate it with other entities
\item[Title] Each Channel has a title, represented by a string
\item[Description] A longer body of text that describes the channel's theme or content
\item[Icon] Reference to the thumbnail image (See below)
\item[Credits] A list of the channel creators and maintainers, or any other people involved.
\item[Donation information] Represented as a snippet of HTML or a simple url.
\item[Website information] A url to link to the channel's main web page.
\item[Tags] 0 or more keywords associated with the channel, used for categorizing and browsing multiple channels.
\item[Permissions] Rules about which users can access or modify the channel
\end{description}

\subsection{Data associated with channel tags}
\begin{description}
\item[Video ID] A reference to the video that the tag describes
\item[Tag name] A short word or phrase to categorize the channel
\end{description}

\subsection{Data associated with Users}
\begin{description}
\item[ID] An arbitrary, unique number to identify the user and associate him/her with other entities
\item[Username] The user's nickname or handle
\item[Password] Self-explanatory
\item[Email Address] Optionally used to verify registration
\item[Permissions] User's access credentials for specific channels, files, and the site in general
\end{description}

\subsection{Data associated with Videos}
\begin{description}
\item[ID] An arbitrary, unique number to identify the user and associate it with other entities
\item[Title] A short amount of text to describe the video
\item[Description] A longer body of text that describes the video's theme or content
\item[Last Modified Date] A time stamp set every time any video information is changed.
\item[Credits] A list of the channel creators and maintainers, or any other people involved.
\item[Icon] Reference to the thumbnail image (See below)
\item[Transcript (optional)] A text-version of the video's content or dialog for the hearing impaired
\item[License/Copyright information] The name of the license associated with the content, and possibly a url to link to the full body of the license
\item[Website url] A link to the video  or publisher's website
\item[Release Date] The date and time the video was released to the public
\item[Publish Date] A timestamp of when the video is made available to the public. note that this is different than release time (For example, a publisher might publish a movie that was released at an earlier time elsewhere).
\item[Running time] The length of the video, in seconds
\item[Adult] A boolean flag used for marking adult content
\item[Donation information] Represented as a snippet of HTML or a simple url.
\item[Tags] 0 or more keywords associated with the channel, used for categorizing and     browsing multiple channels.
\item[Mime-type] The type of media that the file represents
\item[Filename] the url or address on the server where the file is located
\item[Size] the size of the file, in bytes.
\item[Downloads] A running count of the number of users who have downloaded the file
\item[BitTorrent Information (optional)] If the file is a torrent, additional information must be stored (see below)
\item[Permissions] Rules about which users can access or modify the video
\end{description}

\subsection{Data associated with video tags:}
\begin{description}
\item[Video ID] A reference to the video that the tag describes
\item[Tag name] A short word or phrase to categorize the video
\end{description}

\subsection{Data associated with icons}
\begin{description}
\item[Icon ID] A unique, autogenerated id number to identify the image
\item[Icon URL] The address of the icon
\item[Mime-Type] The type of file that the icon is
\end{description}

\subsection{Design Decisions}
The current schema departs from the previous data structures in many ways.
Previously, the data layer was represented as a flat-file database.
Although most of the data structures were organized in a normalized, logical way, there were several inconsistencies that needed to be reconciled.


First, several pieces of data were being improperly stored in the database. 
For example, channel and site settings were being stored in the database. 
This information doesn't typically belong in a relational data structure, simply because it does not interact with other entities, nor can it benefit from any of the features of a database. 
Instead, we decided that the data belongs in a simple, transparent configuration file as part of the template system. 
That way, data can be easily read and modified, both by the application and advanced users. 


Channel icons and video icons, are no longer exclusive, and have been combined into a single icon table.
This means that the same icon information can be used by both channels and videos. This will help eliminate duplicate data, and give users more choice in choosing icons.


The new schema also drops several fields and data structures that could be simplified or generated on the fly.
For example, in the previous version, thumbnails were represented as their own entities, because the database stored the mime-type as well as the file address.
Since most, if not all, browsers render images without an explicit mime-type, eliminating this field also allows us to simplify the schema by storing all of the thumbnail information in the channels and video tables themselves.
Similarly, fields like file extension, which can be derived from other data, have been pruned.
We also store information about intellectual property licenses that could be abstracted to its own table.
However, this doesn't provide any significant functional benefits, so the information has been moved to data fields in other tables. 
File data and video data have a one-to-one relationship, so it makes sense to merge them into one table.
This will normalize the table, which will optimize queries and simplify queries that access that data.


%% Move to design
\chapter{Utilized Technologies}

\section{PHP}
% 1/18/2007, CJ: Rewrote to be more concise. Perhaps talk about PHP vs. Perl, Python, Ruby
Our team chose to write this application in PHP because it is the one server-side scripting language that is guaranteed to be installed virtually everywhere.
As noted previously, it is often installed alongside Apache and there are many service providers that already have it installed on their servers.
PHP as a language is dynamic and weakly typed with a C-like syntax and a large standard library set that geared towards web development.
Other languages such as Perl, Python, or Ruby might be excellent choices, but they do not command the same percentage of the market share that PHP does.


\subsection{Cookies/Sessions}
% 1/19/2007, CJ: Added part about user authentication.
Web applications almost always require users to be authenticated and tracked in some way, and PHP provides convenient ways to do both.
Classic username/password authentication can be used to quickly verify the users identity and through the user of built in session\_* functions in PHP we can easily create persistent user sessions.
More details on how this functionality will be used can be found in the implementation section.


\section{SQL}
% 1/18/2007, CJ: Nassar suggested that there should be some mention of object vs. relational databases here. I don't think there's much to talk about!
To store all of the information about the channels, videos and settings in Broadcast Machine, we decided that a relational database would be best. 
As opposed to previous releases, this version will only have SQL database support.
We figure that since the last release SQL databases have become commonplace.
PHP itself is proof of this, as it easily interfaces with MySQL and SQLite.
We feel that a database lets us store and retrieve data in the most scalable and efficient way possible without sacrificing the overall goals of the program.
It is important to note that the database setup will be automated for the user like it is with weblog package WordPress.
This automation helps us work around the problem of the user having to configure a complex database. (A great concern for us! Many of our users might not be very computer savvy.)


\section{URL Rewriting}
% 1/22/2007, CJ: Rewrote the section about URL rewriting.
In the past few years, URL's have become more and more difficult to understand as web applications have come to dominate.
URL's were designed to be easier to remember than IP addresses, but the've shown they can be just as tough to remember.
One way to make URL's easy to remember is to rewrite them through the use of the Apache module mod\_rewrite.
This module rewrites making the server pretend that a file exists.
When it receives a request for a URL it modifies it based on pre-determined rules that can be set by the user.
These settings can be configured on a per-directory basis by placing the rewrite rules in the .htaccess file.
URL rewriting also serves another purpose.
Apple's iTunes will 
This feature is also necessary to make sure that iTunes can subscribe to feeds produced by Broadcast Machine.
iTunes requires that the file to be downloaded ends as a file extension that it likes.
Unfortunately those file extensions are not usually webpages, they are usually MP3 instead of PHP.
It will only download your MP3 if it looks like \url{http://www.foobar.com/index.mp3?show=4.mp3} versus the traditional \url{http://www.foobar.com/index.mp3?show=4.mp3}. \footnote{http://www.apple.com/itunes/store/podcaststechspecs.html}
Not convenient, but necessary given the popularity of iTunes and the demand for compatible content.


\section{XML and RSS}
% 2/2/2007, CJ: Finished the section. Needs a review/read-through and probably some corrections.
XML itself is a multi-purpose markup language specified by the W3C that provides an enormous amount of flexibility.
It's loosely defined syntax makes it suitable for almost any application imaginable.
One of the most prevalent applications of XML is RSS.
Lately the RSS specification has gained alot of traction as a useful and feasible format for distributing syndicated content.

The format was created as a way for publishers to distribute their content in a 
Unfortunately RSS has has a tumultuous past, with three different and competing versions the format was hardly standard.
The past few years have allowed RSS to mature into the document format that it is now.

XML, or Extensible Markup Language, is a general-purpose language for describing hierarchal relationships with a variety of applications. 
First recommended by the W3C in 1998, XML provides an easy way to convey information that is both human-legible and easily parsed by computer algorithms. 
XML documents start out with a declaration stating what version of XML is being used, information about character encoding, and any other dependencies that the document may rely on:

XML documents start out with a declaration stating what version of SML is being used, information about character encoding, and any other dependencies that the document may rely on:

<?xml version=\"1.1\" encoding=\"UTF-8\"?>

This tag specifies that the document is using the XML 1.1 standard, and is encoded using the UTF-8 character set.

Followed by the declaration, XML files consist of several elements that may be nested within each other, defined by start and end tags.
These tags surround text or other elements, which is referred to as the tag's content.
Tags may have attributes which are embedded into the element's start tag. 
The meanings of each tag and its corresponding content is left intentionally ambiguous, meaning that the XML standard allows users to define what signifigance the tags have, and what data they should contain. 
Customizable schemas supplement the syntactical rules of XML with constraints having to do with element and attribute names, and how the information is organized heirarchically. 
For example, a schema might specify that an XML document describing a bicycle must have an element describing the gears, and only one gearset must be present for a car. 
It might also specify that a set of gears can have several attributes, including manufacturer, number of gears, etc. 


<bike name=\"C200\"\ manufacturer=\"Raleigh\">

<gears manufacturer=\"Shimano\"\ speed=\"21\">Y-42U98010</gear>

...

</bike>


XML is a powerful markup language, and it has been used to construct many popular languages, such as XHTML and RSS.
RSS is an integral part of Broadcast Machine.
The format was developed to allow content producers to publish their content in a way that was easily syndicatable, standardized and inexpensive.
RSS went through an unfortunate period where many individuals and groups wanted undue control over what the standard was going to be.
Lately publishers have begun to settle on the RSS 2.0 specification.
While RSS 2.0 is not governed by a traditional standards body such as 
the W3C or ISO the specification is taken care of by the RSS-DEV working 
group at Harvard University. \footnote{\url{http://en.wikipedia.org/wiki/RSS-DEV\_Working\_Group}}
The RSS 2.0 specification allows for publishers to specify \'channels\' in which there are repeating elements of \'items\' which contain the main content.
At the top of the RSS file there is an area where the publisher can add information about the channel such as a link to the publishing website, the author, webmaster and other various information.
Each of the items within the channel contain additional sub-elements that describe the item.
There are descriptors for the time and date at which the content was published, links to the website with the extended or full version of the contents, and ususally there is a unique identifier that lets the computer detect duplicates. 
\begin{verbatim}
<?xml version=\"1.0\"?>
<rss version=\"2.0\">
  <channel>
    <title>Boston Concerts</title>
    <link>http://bostonmusic.org</link>
    <description>A collection of concerts in Boston.</description>
    <language>en-us</language>
    <pubDate>Tue, 10 Jan 2006 04:00:00 GMT</pubDate>
    <lastBuildDate>Tue, 10 Jan 2006 09:41:01 GMT</lastBuildDate>
    <docs>http://blogs.law.harvard.edu/tech/rss</docs>
    <generator>Weblog Editor 2.0</generator>
    <managingEditor>bob.jones@bostonmusic.org</managingEditor>
    <webMaster>webmaster@bostonmusic.org</webMaster>

    <item>
      <title>Dave Brubeck</title>
      <link>http://bostonmusic.org/2007/01/02/brubeck</link>
      <description>Dave Brubeck is coming to the Somerville Theatre this Saturday!</description>
      <pubDate>Tue, 03 Jun 2003 09:39:21 GMT</pubDate>
      <guid>http://bostonmusic.org/2007/01/02/brubeck</guid>
    </item>

  </channel>
</rss>
\end{verbatim}
This example provides us with exactly what anyone would need to push content updates around the internet.
Unfortunately the internet isn't only text and images, it's a place full of music and video too.
Recently, publishers have begun to embed video and audio into RSS feeds that provide users with an experience much like broadcast television or radio.
With audio this method has been called \"Podcasting\" and the same method but with video has been called \"Broadcatching\".
The RSS format is built to handle text (which it does very well) but third parties have had to create extensions to the current RSS 2.0 standard that allow them to have fields for audio, video and miscellaneous metadata.
Much to our dismay, we found that there wasn't any agreement on what this new standard should be.
As it stands now, Apple and Yahoo are pushing their own extensive additions while other publishers are using an older yet effective method.
The simplest solution is to use the <enclosure> tag.
It is an optional sub-element of the <item> tag and lets the publisher specify a url for the media, a mimetype and a length in bytes for filesize.
The tag is an official part of the RSS 2.0 specification and it provides basic and effective functionality.
Its featureset unforuntately pales in comparison with what can be done with Apple's or Yahoo's extensions.
The Apple extension was the next option to appear.
With the rise in popularity of Podcasting, Apple was quick to capitalize on the trend by adding support to its prevalent iTunes application.
The large iTunes user base is a boon to publishers who want to easily reach such a large market like that.
Unfortunately to reach those people, Apple requires that your RSS feed be formatted using their extensions. \footnote{\url{http://www.apple.com/itunes/store/podcaststechspecs.html}}

The first step in creating an iTunes RSS feed is to include the XML namespace declaration for the iTunes tags.
Simply place the following text at the top of the feed, and step one is done.
\begin{verbatim}
<rss xmlns:itunes=\"http://www.itunes.com/dtds/podcast-1.0.dtd\" version=\"2.0\">
Next, the publisher needs to add tags that describe the channel.
iTunes specifies a special tag for describing the owner of the feed.
Enclose the name and email address of the producer as such:
  <itunes:owner>
    <itunes:name>Bob Jones</itunes:name>
    <itunes:email>bob.jones@bostonmusic.org</itunes:email>
  </itunes:owner>
There is also a section where the publisher can link to an image for the podcast.
   <itunes:image href="http://bostonmusic.org/brubeck.jpeg" />
For describing the content there is a field where people can specify categories for their feeds.
	<itunes:category text=\"Music\">
      <itunes:category text="Jazz"/>
   </itunes:category>
\end{verbatim}   
It is important to note that the category tags can be paired with a beginnng and an end or alone.
We should also pay attention that it is possible to nest categories, effectively creating subcategories that iTunes recongizes.
The RSS items themselves can also be extended.
Publishers might like to specify an author for each item. (Perhaps the feed is a collection of videos from other people.)
It can be specified using the <itunes:author> tag.
The media can also be supplemented by a small summary.
The <itunes:summary> tag is especially useful.
When it comes to the audio or video file, the iTunes specification uses the <enclosure> tag mentioned earlier.
To further describe the content iTunes allows for keywords and tags to be added to each item using the <itunes:keywords> tag.
We can see how this all comes together in this example item:
\begin{verbatim}
	<item>
		<title>Dave Brubeck - Take Five</title>
		<itunes:author>Dave Brubeck</itunes:author>
		<itunes:subtitle>Imagine yourself walking through the city.</itunes:subtitle>
		<itunes:summary>
			Dave Brubeck takes us on an adventure in Jazz.
		</itunes:summary>
		<enclosure url="http://bostonmusic.org/brubeck.mp3" length="4989537" type="audio/mpeg" />
		<guid>http://bostonmusic.org/brubeck.mp3</guid>
		<pubDate>Wed, 1 Jun 2005 19:00:00 GMT</pubDate>
		<itunes:duration>3:59</itunes:duration>
		<itunes:keywords>dave brubeck, jazz</itunes:keywords>
	</item>
\end{verbatim}
The competing standard is Yahoo!'s Media RSS \footnote{\url{http://search.yahoo.com/mrss}} specification which puts forth an even larger set of extensions to RSS 2.0.
One difference between the Yahoo and Apple specifications is that Yahoo's additions are with respect to the item that is enclosed rather than to the RSS item itself.
The Apple specification approached a restructuring of the RSS file while the Yahoo modifications are strictly media-centric metadata.
This difference makes the Yahoo additions more desireable for embedding rich content within ordinary text feeds while the Apple additions push RSS as a multimedia only platform.
\begin{verbatim}
<rss version=\"2.0\" xmlns:media="http://search.yahoo.com/mrss\"
xmlns:dcterms=\"http://purl.org/dc/terms/\">
<channel>
<title>Music Videos 101</title>
<link>http://www.foo.com</link>
<description>Discussions of great videos</description>
	<item>
		<title>The latest video from an artist</title>
		<link>http://www.foo.com/item1.htm</link>
		<media:content url=\"http://www.foo.com/movie.mov\" fileSize=\"12216320\" 
		type=\"video/quicktime\" expression=\"full\">
		<media:player url=\"http://www.foo.com/player?id=1111\" 
		height=\"200\" width=\"400\"/>
		<media:hash algo=\"md5\">dfdec888b72151965a34b4b59031290a</media:hash>
		<media:credit role=\"producer\">producer's name</media:credit>
		<media:credit role=\"artist\">artist's name</media:credit>
		<media:category scheme=\"http://blah.com/scheme\">music/artist 
		name/album/song</media:category>
		<media:text type=\"plain\">
		Oh, say, can you see, by the dawn's early light
		</media:text>
		<media:rating>nonadult</media:rating>
		<dcterms:valid>
			start=2002-10-13T09:00+01:00;
			end=2002-10-17T17:00+01:00;
			scheme=W3C-DTF
		</dcterms:valid>
		</media:content>
	</item>
</channel>
</rss>
\end{verbatim}
From this example we can see how the specification does not place any of the tags in the section with the channel, everything is with the item.
The most notable change is the movement from the <enclosure> tag to the use of the <media:content> tag.
Unfortunately there isn't much improvement, as they are the same thing by different names.
The second is the specification of a media player that can be used to play the video.
This is particularly useful in a world of Adobe Flash video where there are FLV files and SWF players.
The next <media:hash> tag is a welcome addition as it lets the computers on the receiving end verify the integrity of file that they have just downloaded.
Just like the Apple extensions, Yahoo allows the <media:category> and even lets the publisher specify the scheme by which the categories are laid out.
There is also a <media:text> tag that lets the publisher add a short description of the current media being played.
The last part is a bit curious as the Yahoo specification recommends that the publisher include a small part about XML Dublin Core compatibility and how the file can be verified.

With these three different ways of pushing rich content with RSS there is certain variety.
All of these need to be supported in Broadcast Machine.
The simple enclosure method is supported by a large number of clients making it an easy choice.
Apple iTunes fans are not to be left out as they are such a large community.
Supporting Yahoo Media RSS is a must because of Democracy Player's support for the format.

% 2/1/2007, CJ: Blurb on HTTP caching?

\section{XHTML}
% 1/25/2007, More needs to be added about CSS.
XHTML, or the Extensible HyperText Markup Language, is a markup language that allows the same amount of versatility as HTML, but with a stricter syntax. 
HTML is an application of the Standard Generalized Markup Language (SGML), a very versatile markup language, whereas XHTML is an application of XML, a more restrictive subset of SGML. 
XHTML is a reformulation of HTML in XML, so in many ways its a cross between XML and HTML. 
Because XHTML code needs to be well-formed and syntactically correct, XHTML documents allow for automated processing to be performed using a standard XML library. 
This is unlike HTML, which due to its leniency requires a relatively complex and usually custom parser. 


XHTML 1.0 became an official World Wide Web Consortium (W3C) recommendation on January 2000. 


\section {CSS}
% Sources:
% http://en.wikipedia.org/wiki/Stylesheet\_language
% http://en.wikipedia.org/wiki/Cascading\_Style\_Sheets
CSS, or Cascading Style Sheets, is presenation language used to style structured documents, such as XHTML, HTML, SVG, and other markup languages. 
It's best know for being used with XHTML and HTML. 
The power of CSS and structured documents becomes 

\section{Changes to the Database}
In the new database model, several changes will have to be made in order to normalize the database for increased performance and easier programming. These changes are listed below:


The stats table has a one-to one relationship with the files table. This means that the two tables can be merged, and tracking the number of downloads can be relegated to a single field in the files table. The channel\_options table is also one-to-one with the channels table, so all of its data can be stored in the channels table.


The instance table can be replaced by a field in the channel settings for the base url of the website. We'll be able to assume that if, when a user goes to set up Broadcast Machine, the base URL has been filled already, then more than one copies of the program are sharing the database. Then, the user will be given a warning and a choice to overwrite this information with the new site.


A number of fields and tables will become deprecated in the new model. CSSUrl, from the channels table, will be replaced by the new templating system. As features associated with channel\_sections are widely unused, they will also be left out of the new schema, but may be added back in later. The files table contains the runtime of the video via three fields, RuntimeHours, RuntimeMinutes, and RuntimeSeconds. These fields will be combined into one runtime field representing the time in seconds, which will be converted into the h:mm:ss format in the file view rather than at the data-layer level.


The files table is poorly named, since it really stored information on videos, not the files that the videos are encoded in. In the future, it should be possible to have multiple files associated with one video (for hosting multiple formats and resolutions). The name of this table should be changed from files to something more descriptive, such as videos.


In the users table, the primary key field is Name, which may have caused problems when two people with the same name would attempt to register (e.g. two John Smiths would not be allowed to join at the same time). In the future, the primary key for the table should be username, which should always be unique.


Site settings will be moved from a B-Encoded file to a table in the database. Since we will be using http-seeding of torrents, some of these settings are expected to change.


\end{document}

