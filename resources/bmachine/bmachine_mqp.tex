\documentclass[a4paper,12pt]{report}
\author{Christian Bryan, Greg Opperman, Drew Wilson}
\date{\today}
\title{Broadcast Machine}

\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{hyperref}

%% Things that need to be in this paper by the end of B term
%%
%%  * The background section of the paper should be finished. This includes:
%%    * The importance of open media and the importance of an open internet
%%      for open media (Greg)
%%    * Reviews of similar software including Ruby, Rails, Wordpress,
%%      Drupal/CivicSpace. (Simon for Wordpress - drew)
%%    * Explanations of the technologies we plan to use including HTTP,
%%      PHP, BitTorrent, Apache, SQL, and RSS (CJ?)
%%  * A very detailed explanation of the existing data structures. This is
%%    vital for understanding the program. I've done most of the difficult
%%    work. (Greg)
%%  * A loose set of requirements. Having the existing data structures will
%%    give you most of this. (Greg)
%%  * A plan for architecting the software. We expect this will change a
%%    little.
%%  * Enough of a start on the code to give us a proof-of-concept for the
%%    architecture
%%  * Unit tests for that code that integrate into the Democracy PyUnit test
%%    framework

%% Things that are completed:
%%  * Brief history of the software and PCF (Greg)
%%  * Why we're building this on PHP/SQL (See Requirements)
%%  * An overview of the existing software, how it's architected, and
%%    what's wrong with it. Include comments about MVC and the existing
%%    documentation. (CJ)

%% Things that need work:
%%  * A database schema that matches those requirements with a detailed
%%    prose explanation. We expect this will change a little. (Not prosy
%%    enough - Greg)

\begin{document}

\maketitle

\tableofcontents

\chapter{Background}
% I had this from a section below, but it didn't fit. Thought it might fit here...
%Providers of Internet video have recently seen an explosion in users\foonote{"We're seeing an explosion in the popularity of television content with Internet audiences, and Time Life's video library is growing every day," said Adam Berrey, vice president of marketing and strategy, Brightcove. "Using Brightcove enables Time Life to bring video content directly to its fans with experiences that communicate its brand and integrate directly into online fan sites and social networks." According to \url{ http://www.prnewswire.com/cgi-bin/stories.pl?ACCT=104&STORY=/www/story/12-12-2006/0004489645&EDATE=} }.

\section{About the Participatory Culture Foundation}
    The Participatory Culture Foundation is a 501c(3) non-profit organization dedicated to the creation of a democratic mass medium through internet technology.
Based in Massachussetts, it was founded by Worcester natives Nick Reville, Tiffiniy Cheng, Holmes Wilson, and WPI alunmus Nick Nassar.

    PCF seeks to achieve its goal of democratizing the media through their open-source Internet TV platform, consisting of several pieces.
Democracy Player allows users to download and watch videos from all over the world via RSS channels.
Still in beta, Democracy Player has been rapidly expanding its user base as it draws closer to a 1.0 release.
In the month of November 2006 alone, the application was downloaded over 15,000 times\footnote{Citation/Number update needed}.

Integrated seamlessly with Democracy, the Channel Guide serves as an open directory for internet television channels, ranging from local citizen journalism to major network programming.
Any video publisher may submit their show to the Channel Guide, which users can then peruse by category from within Democracy.

Videobomb is a website for aggregating the best videos online, allowing users to create custom channels of videos from all over the web.
Users post content that they think is noteworthy.
Other users may "Star" the video, which bookmarks it as a favorite.
The newest and most popular videos are aggregated onto the site's front page, or downloaded via feeds that integrate with Democracy Player. 

\section{What is Democracy Player?}
Democracy player is the principal component in the collection of tools that make PCF's Internet television platform possible.
Democracy Player is a cross-platform media player that has built in support for reading Internet TV channels.
Democracy Player can read any RSS feed with embedded video and organize the videos in a clear, logical way.
When looking though Internet TV channels, the videos are listed by date.
Each video has a thumbnail, a short description, various meta-data, a link to rate the content, and a link to share the content with friends.
The software enables users to easily subscribe to free Internet TV channels.
In other words, Democracy will automatically download any new content from an RSS feed that contains embedded video content.
The videos are stored for certain period of time (5 days by default) before being deleted.
Democracy Player is different than web services like You Tube in that it does not provide hosting for videos, instead only acting as an aggregator for video content that is hosted elsewhere on the web.

\section {What is the Channel Guide?}
Democracy makes viewing Internet TV channels easy, but without a central directory of free channels, it might be hard to find interesting channels.
Channel Guide makes finding free Internet TV channels easy.
It is a website that is embedded in Democracy that centralizes information about popular free Internet TV channels.
It allows users to easily browse, subscribe to, comment on, and rate free channels.
It's built into Democracy, so it's easy to find.
Channel Guide had hundreds of channels about everything from citizens news channels, such as Democracy Now!\footnote { http://DemocracyNow.org} and Rocketboom\footnote {http://Rocketboom.com}, to independent music video channels like TeleMusicVision\footnote{ http://telemusicvision.com}.
It is also possible for users to create their own channel guides and distribute their own branded versions of Democracy Player.
Democracy makes viewing Internet TV channels easy, but without a central directory of free channels, it might be hard to find interesting channels. 
Channel Guide makes finding free Internet TV channels easy. 
It is a website that is embedded in Democracy that centralizes information about popular free Internet TV channels. 
It allows users to easily browse, subscribe to, comment on, and rate free channels. 
It's built into Democracy, so it's easy to find. 
Channel Guide had hundreds of channels about everything from citizens news channels, such as Democracy Now!\footnote {http://DemocracyNow.org} and Rocketboom\footnote {http://Rocketboom.com}, to independent music video channels like TeleMusicVision\footnote{http://telemusicvision.com}. 
It is also possible for users to create their own channel guides and distribute their own branded versions of Democracy Player. 

\section{What is Broadcast Machine?}
    The final piece of the platform is Broadcast Machine, a tool that allows video producers to publish their content online.
    Broadcast Machine began as Blog Torrent, a small application that simplified the creation and sharing of torrent files, as well as acting as a light-weight BitTorrent download client.
Broadcast Machine built on that foundation, expanding the application to a full-featured toolkit for internet video publishers (commonly referred to as vloggers).
It not only handles video distribution via BitTorrent, but also supports direct downloads, syndication, categorization (tagging), extensive information about the videos themselves, and more.
Broadcase Machine uses open standard to ensure compatibility with many feed readers, like Democracy Player, RSSowl, LifeRea and iTunes.
The software organizes video content in a way that makes it easy for the layperson to download video, subscribe to channels, and share content with friends.
	The final piece of the platform is Broadcast Machine, a tool that allows video producers to publish their content online. 
	Broadcast Machine began as Blog Torrent, a small application that simplified the creation and sharing of torrent files, as well as acting as a light-weight BitTorrent download client. 
Broadcast Machine built on that foundation, expanding the application to a full-featured toolkit for internet video publishers (commonly referred to as vloggers). 
It not only handles video distribution via BitTorrent, but also supports direct downloads, syndication, categorization (tagging), extensive information about the videos themselves, and more. 
Broadcase Machine uses open standard to ensure compatibility with many feed readers, like Democracy Player, RSSowl, LifeRea and iTunes. 
The software organizes video content in a way that makes it easy for the layperson to download video, subscribe to channels, and share content with friends. 

\section {Why do we need Broadcast Machine?}
    Broadcast Machine is an amagalmation of features from a number of different pieces of software.
It is a type of content management systems, much like Drupal\footnote{\url{http://Drupal.org}} and Civic Space\footnote{\url{http://CivicSpaceLabs.org} }.
Since there regular posts make up the main content in Broadcast Machine, it also is somewhat similar to blog software like Wordpress \footnote{\url{http://WordPress.org}} and Movable Type \footnote{\url{ http://MovableType.com}}.
In fact, The Channel Channel, one of the default channels in Democracy Player, is powered by a customized version of Wordpress.
Broadcast Machine is different from these pieces of software in that it primarily manages video content and it adds the videos to Democracy compatible channels.
Since current CMS's were not designed with large files in mind, hosting video files can lead to extreme strain on the server.
Broadcast Machine solves the problem of high demand for bandwidth by using BitTorrent to distribute video content.
With a number of custom plugins and work-arounds, each of these pieces of software could undoubtedly accomplish the goals of Broadcast Machine.
However, since none of these pieces of software were not designed with video content in mind, the work required to get them to support all the requirements of Broadcast Machine is comparable to writing Broadcast Machine from scratch.
It would probably cost us more time to first read and understand the existing code of a CMS or blog software and then turn it into what we need, than it would to just start from scratch.
Below we will discuss the pros and cons of these pieces of software and explain more why it is neccesary for us to design a new architecture for Broadcast Machine.
	
\section {The importance of open-source}
    Open source software is an important part of the movement to democratize the media and Internet.
This common goal is what ties together PCF's mission with that of the Free Software Movement.
The goal of the Free Software Movement is to create software to increase the freedom of the public in general.\footnote{Richard Stallman, Why Software Should Be Free (\url{ http://www.gnu.org/philosophy/shouldbefree.html})}
Open-Source Software accomplishes this through its transparency, which inspires community development of software, and gives users the freedom to modify the software to suit their needs.
The software is Free in the sense that there are no conditions in distributing or using it, except that users respect the freedom of the software.

    Without Free software, the Internet could not exist as a democratic medium.
Proprietary (meaning closed-source) software limits what users can or can't do with it, and does not give users the ability to modify code.
With proprietary software, users cannot \"own\" software, even if they purchase it.
Instead, users pay for the privilege of using it.
Under this model, the software is less accessible and less usable (as users cannot fix problems on their own, and must rely on proprietary developer support).
On top of this, other developers cannot learn from existing code, or base new work on it without paying costly licensing fees.\footnote{ibid} 
    Open-source software aims to build a cultural community of developers who can use each other as resources, learning from existing code, and freely building upon it to create new technologies altogether.
This culture encourages technological progress in ways that competitive, closed-source software does not. 

\section {Similar Technologies}

\subsection {Drupal \& Civicspace}
%Needs: How Drupal Modules Work
Drupal is a content managment system, often referred to as a CMS. 
A CMS is a computer software system that assists users in managing internet content.
It helps users organize, control, and publish content.
Drupal allows users to easily set up and create and moderate blogs, forums, webpages, newsletters, and picture galleries\footnote{According to \url{ http://drupal.org/about}}.
It's written in PHP and requires either MySQL v3.23.17 or higher or PostgreSQL 7.2 or higher\footnote{As of Dec 11, according to \url{ http://drupal.org/requirements}.}.
Thousands of popular sites use Drupal\footnote{As of Dec 15, 2006, according to \url{http://DrupalSites.com}}, including The Onion\footnote{\url{ http://TheOnion.com}}, OurMedia\footnote{\url{http://www.ourmedia.org/}}, and MTV's UK site\footnote{\url{http://mtv.co.uk/} }.
The IndyMedia network is also considering using Drupal as the base for their new website\footnote{As of Dec 15, 2006, according to \url{https://docs.indymedia.org/view/Global/IndymediaAlternatives} }.

Civicspace, formerly known as DeanSpace and Hack4Dean, was born of a distribution of Drupal developed for Howard Dean's 2004 presidental campaign website\footnote{\url{ http://en.wikipedia.org/wiki/DeanSpace}}.
CivicSpace features an installer and many pre-configured plugins that are meant to help run political and charitable websites.
CivicSpace is used by a huge number of websites, somewhere around 40,000 sites\footnote{As of Dec 11, according to a google search for \"powered by CivicSpace\".}, such as The New Democratic Party\footnote{\url{ http://www.ndp.ca}}, Better Donkey\footnote{\url{http://BetterDonkey.org}}, Blog for America\footnote{\url{ http://www.blogforamerica.com/}}, and Oregon's Bus Project\footnote{\url{http://www.busproject.org}}.
As of version 5.0, Drupal includes an automatic installer and many of the functionality that set CivicSpace apart from Drupal are being included in the base software.
%templating system - check below and let me know what you think
%architechture - ditto

\subsubsection {Templating and Themes}
%Needs: Template code examples
Drupal has a very flexible templating system. 
It has a built in theme system and supports a number of common engines. 
A theme can be formed in several ways. 
As of version 5.0, Drupal interfaces with Smarty, XTemplate, and PHPTemplate. 

Themes are stored in individual directories under the Drupal theme directory. 
Each theme directory bares the name of the theme and at least contains the following files:
logo.png - an image that will be displayed next to the url of in a viewer's browser
screenshot.png - an image that will be displayed in the administration inferface. 
It is meant to give users deciding on a new theme a preview of how the theme will look before they switch. 
style.css - a CSS file containing all of the styling information about the theme. 

Depending on what method the theme developer uses to create the theme, there will need to be a number of other files included in the theme's directory. 
There are a few ways to properly form a new theme for Drupal. 
One of the most common ways is for the theme developer to create a PHP file with a .theme extension that includes functions that override the default theme functions, as well as HTML or XHTML. 
The functions defined in this file is used in conjunction with the style.css file to create the layout of the page. 
Chameleon is an example of a theme that was designed using a .theme file to override the default theming functions.
The Chameleon theme directory contains the following files: 
Chameleon.theme - the PHP file that contains the theme\_functions 
style.css - the primary style sheet
common.css -  another style sheet that has more styling info
screnshot.png, logo.png - images used by the administration interface
background.png - simple background image

Below is the Chameleon function that overrides the default Drupal node function.

function chameleon_node(\$node, \$teaser = 0, \$page = 0) {

  \$output  = "<div class=\"node". ((!\$node->status) ? ' node-unpublished' : '') ."\">\n";

  if (!\$page) {
    \$output .= " <h2 class=\"title\">". (\$teaser ? l(\$node->title, "node/\$node->nid") : check_plain(\$node->title)) ."</h2>\n";
  }

  \$output .= " <div class=\"content\">\n";

  if (\$teaser && \$node->teaser) {
    \$output .= \$node->teaser;
  }
  else {
    \$output .= \$node->body;
  }

  \$output .= " </div>\n";

  \$submitted['node_submitted'] = theme_get_setting("toggle_node_info_\$node->type") ? array('#title' => t("By !author at @date", array('!author' => theme('username', \$node), '@date' => format_date(\$node->created, 'small')))) : array();

  \$terms = array();
  if (module_exists('taxonomy')) {
    \$terms = taxonomy_link("taxonomy terms", \$node);
  }

  \$links = array_merge(\$submitted, \$terms);
  if (\$node->links) {
    \$links = array_merge(\$links, \$node->links);
  }
  if (count(\$links)) {
    \$output .= '<div class="links">'. theme('links', \$links, array('class' => 'links inline')) ."</div>\n";
  }

  \$output .= "</div>\n";

  return \$output;
} 

As you can see, presentation elements and application code are closely intertwined. 
All presentation elements are appended to \$output, which is eventually returned to the base code to be output.


Alternatively, a new theme can be created using one of the supported theme engines. 
A developer determines which templating engine he or she is going to use and creates a file with a .xtmpl, .tpl, or a .tpl.php extension. 
Supported templating engines include: XTemplate, PHPTemplate, and Smarty. 
Pushbutton and Bluebeach are two themes that are distributed with Drupal that were created using this method. 

PHPTemplate is a theme engine created by Adrian Rossouw specifically for the Drupal project. 
Unlike Smarty and XTemplate, it does not need to be interpreted by another theme engine. 
This means PHPtemplate can execute faster. 
Every PHPTemplate file contains an HTML skeleton with some simple PHP statements for the dynamic data. 
PHPTemplate is a good choice for theme developers who know a bit of PHP, just like in Wordpress, with some basic PHP snippets you can create complicated themes easily. 
On the flip-side PHPTemplate is not good for people who are new to programming, or don't know any PHP. 
Although theme designers do not neccesarily need to understand what the php snipets do, requiring code in the template could confuse the designers and could easily lead to trouble. 
Code in the templates is a major drawback of the PHPTemplating engine. 
It makes template design less accessible to ordinary users. 

Internet Center Theme, the theme for \url{http://www.openwebdesign.org}, was built using PHPTemplate. Below is a snippet of code that demonstrates how PHPTemplate looks. 

<div class="logo">
        <?php if (\$site_name) : ?>
            <?php if (\$site_name) { ?><h1 class='site-name'><a href="<?php print \$base_path ?>" title="<?php print t('Home') ?>"><?php print \$site_name ?></a></h1><?php } ?>
        <?php endif;?>
</div>

Notice how difficult it is to see just the design elements. 
Imagine if you were just trying to change the look of the page. You would need to first determing which parts of the code are exclusively presentation elements and which were logical elements. 
To someone who has never seen PHP script, and is unfamiliar with programming, the code above would be very confusing. 
They might accidentally delete an integral part of the code or accidently forget a question mark at the end of a PHP and not know how to fix. 
They might be forced to learn some basic PHP programming just to change the layout or style of a page, which somewhat defeats the purpose of having a templating system.


XTemplate is rather different from PHPTemplate and the theme engine built in to Drupal, but in many ways it's similar Smarty. 
It separates the layout into three layers: logic, structure, and style, making it easy for theme designers to create and modify templates. 
Designer need not deal with the logic layer to make a new theme or modify an existing one. 
This logic layer is made up of all the PHP code necessary to make the theme run. 
It contains all of the functions required to interface the template with Drupal. 
The structure layer consists of an XHTML code that establishes the general layout of the code. 
The style layer is made up of the CSS code that adds the finishing touches to the design. 
In concept it is very much like Smarty, the major differences between the two are in syntax.
Bluebeach, the theme used by \url{http://drupal.org} was originally written as a XTemplate theme, but was later ported to be a smarty-based theme. As of version 5.0, Drupal no longer includes XTemplate as a default templating engine but it does remain as a module mantained by user contribution. 
For this reason, many themes that were originally written in XTemplate are now being converted to Smarty. 


A quick way to create a new theme is to use a theme that is already in existance and simply create a new style sheet that changes the layout and look. 
Marvin and Box Cleanslate are themes that were both created by editing the existing style sheets of previous themes. 
Marvin is based on Chameleon and Cleanslate is based upon Box\_grey.  




\subsection {Architecture}
Modularity is a key element in the design of Drupal.
A modular design provides flexibility, adaptability, and extensibility, which allows users with some knowledge of programming to customize their experience.

A Drupal module is nothing more than a plain text file which contains PHP code. 
Module code is executed during the normal runtime of the site, not beforehand or afterwards. 
This allows the modules access to all of the functions, variables, and data structures of Drupal base code. 
In fact, a Drupal module isn't any different than an regular PHP file, the only difference the way in which it is concieved by the programmer and the how it is abstracted to a single file. 
The developers of Drupal believe this model lends itself to good programming principals. 
They believe that "modularity better suits the open-source development model, because otherwise you can't easily have people working in parallel without risk of interference"\footnote{\url{http://drupal.org/node/292}}. 


The main idea of the Drupal module system is to allow module developers to inject code at certain places in the base code. 
This injected code can then enhance or modify the functionality of the software. 
The certain places where code can be injected by the module system are refferred to as "hooks" and are defined in the API. 

When the engine comes across a place in the base code where hooks are available, the engine iterates through all of the modules in the modules directory looking for a module that uses that hook. 
For example, we have a module named "billyclub", which is naturally located in /modules/billyclub.module. If there exists a hook called "fancypants" and the module "billyclub" exports to that hook, the engine will call the function named "billyclub_fancypants()" in /modules/billyclub.module.


\subsection{Smarty Templating}
Smarty is often called a templating engine, but may be better described as a template framework. 
Smarty integrates with CSS, XHTML, and PHP to create a framework for abstracting presentation elements (XHTML and CSS) from the logic layer. 
It's a flexible tag based system which allows template designers all the functionality that they might need, without requiring them to understand any PHP syntax.
It also allows programmers to increase the functionality of the templating language based on the needs of their specific application. 

 
Smarty works by adding another parsing layer before the PHP parser. 
This pre-parser converts smarty tags to plain text, variables, or PHP code, then passes the parsed text on to the PHP interpreter. 
The smarty engine is installed by copying the library files to your webserver and adding an include statement to the header of your PHP application. 
The Smarty engine is distribute as a tarball from \url{http://smarty.php.net}. 
Decompressed, file structure should look like this:

../Smarty/
                          Config_File.class.php
                          debug.tpl
                          internals/
                          plugins/
                          Smarty.class.php
                          Smarty_Compiler.class.php

Using Smarty is easy and in many ways is very similar other PHP templating engines. 
In the PHP application, the application developer starts be assigning variables for use in the template. 

include('Smarty.class.php');

// create object
\$smarty = new Smarty;

// assign some content. This would typically come from
// a database or other source, but we'll use static
// values for the purpose of this example.
\$smarty->assign('name', 'george smith');
\$smarty->assign('address', '45th & Harris');

// display it
\$smarty->display('index.tpl');


To someone who knows XHTML and CSS, Smarty templates are very easy to read. 
Tags are escaped using curly brackets, { and }. 
For example, imagine we add the following two lines to our template, index.tpl. 

Name: {\$name}<br>
Address: {\$address}<br>

The output would be:

Name: george smith<br>
Address: 45th & Harris<br>

% sources http://smarty.php.net/crashcourse.php
% http://smarty.php.net/rightforme.php
As shown above, Smarty clearly separates presentation elements from application code. 
It divides the application into two distinct layers. 
However, it's important to note that it does not entirely remove logic from the templates. 
Smarty's design principles allow for the inclusion of logic as long as the logic pertains to the presentation. 
For example, looping over table row colors would be considered presentation logic and would be allowable. 
The application layer shouldn't be concerned with this sort of thing, it's a design decision. 
The idea is that template designers should be able to completely change the templates and rebuild them without even seeing the application code.
There is nothing stopping developers from including application logic in the template layer, but doing so would undermine the reason for using a templating system. 
Smarty is flexible enough to allow misuse of its, but if used correcly it can make theme developement a lot easier on non-programmers. 
Below is an example of how presentation logic can be included in the template layer without bogging down the template designer with application code. 

    {foreach from=\$data item="entry"}
        <tr bgcolor="{cycle values="#dedede,#eeeeee" advance=false}">
            <td>{\$entry.Name|escape}</td>        
            <td align="right">{\$entry.EntryDate|date_format:"\%e \%b, \%Y \%H:\%M:\%S"}</td>        
        </tr>
        <tr>
            <td colspan="2" bgcolor="{cycle values="#dedede,#eeeeee"}">{\$entry.Comment|escape}</td>
        </tr>
    {foreachelse}
        <tr>
            <td colspan="2">No records</td>
        </tr>
    {/foreach}

Smarty also allows for variables and variable modifiers  

\subsection {Wordpress}
%need this again
Wordpress and Movable Type are pieces of blogging software. 
They're CMS's that are designed specifically for a single user or a small group of users who will regularly post text and image content. 
Wordpress is PHP 4.2 and uses MySQL 3.23 as its database backend. 
It was created with the vision of creating a powerful GPL-licsenced internet publishing platform based on open standard. 
The first version was released in 2001. 
Wordpress is blogging software designed to be installed on an individual's webhost, either their own computer connected to a broadband connection or a commercial webhost like Dreamhost or 1and1. There exist services such as the one at \url{http://Wordpress.com} that provide webhosting and just provide users with the a fresh install of Wordpress, but for the most part Wordpress users install the software themselves. 

\subsubsection{Templating System}
Theming is a little more standard in Wordpress than in Drupal. 
Wordpress uses a single custom engine that's similar to the PHPTemplate in Drupal. 
Although there seems to be some effort given to abstracting presentation element, it doesn't appear to be much. Style element has been moved into a seperate CSS file, style.css, but in some popular themes CSS positioning is located in the same file as all of the style data.
Furthermore, a lot of PHP code is embedded in the templates. 
There tends to be a lot of logic, even non-presentation logic, contained in the theme. Needless to say, it can get rather confusing for the novice programmer or template designer. 
Nearly all themes are made up of the following 9 files. At a minimum, a theme must include index.php and style.css. 

style.css - contains all of the the theme's styling information.
header.php - header for each page.
sidebar.php - sidebar layout and data. 
searchform.php - template for the page that returns search results.
index.php - template for the main page. Calls the header and sidebar.
category-2.php - template for the second category.
comments.php - template for the comments section, which is included whenever comments are displayed.
single.php - template for the view post view.

The code in the these templates is comprised of XHTML and PHP code. 
One of the major problems is that the XHTML is not consistently in the same place. 
Sometimes XHTML is located within a PHP code block and sometimes it is outside of the code block. 
Unlike Drupal and the current version of Broadcast Machine, Wordpress does not have an output variable that is updated throughout the template then later output as one output statement. 
This makes things even more confusing for non-programmers because, without knowing PHP, he or she may not know what code effects presentation and what code effects the logic. 
It makes it very easy for someone to break the program while attempting to only modify a theme. 

In Wordpress, all pages are generated on the fly, there's no server-side caching. 
Each file is included at some point during the run of the engine. 
This has its advantages and its drawbacks. 
The advantage is that it is not neccesary to rebuild pages every time you make a minor change. 
A drawback is that each page requires time to built and delivered. 
If your blog gets a lot of traffic in a short period of time, performance may drop dramatically. A number of plugin have been developed to deal with this problem, but no solutions to this problem have been incorporated into the base code of the application. 



\subsubsection{Architecture}
The way in which the templating system works is very closely related to how the program is architected. 
Every time someone goes to the index page of a Wordpress site (e.g. http://blogurl.com/wordpress/index.php) the engine starts by reading a configuration file and checking settings from the database. 
Next the Wordpress engine goes to the appropriate theme directory and parses the main index file, index.php. 
At a minimum this theme will reference style.css, but most of the time themes include a header, footer, single post template, comments template, and a sidebar template. 
In most cases the main index file first includes the header file, then the siderbar, then the content section is executed from within the main index file, and then finally the footer is included. 
The content section is usually comprised of a set number of the most recent posts. 
This part of the template code is also sometimes referred to as The Loop. 

In order to get a good idea of the how Wordpress is architechted, it's almost important to look at how it handles plugins. 
A plugins is a PHP file that is stored in the /wp-content/plugin/ directory. It need not be in its own individual directory, although many plugins are distributed this way.
To install a plugin, the blog administrator must copy the plugin file to the /wp-content/plugin/ directory, then log into the administrative back-end. 
From there the user locates the plugin in must click the "activate" link. 
In order for the Wordpress engine to actually use the plugin, a call to the plugin must be places somewhere in the theme. 
These calls are PHP function calls that return a certain output. 
For instance, take the OpenForBusiness plugin. OpenForBusiness is a module is designed to allow users who run a business to publish their hours. 
After activating 




As you can see, Wordpress doesn't have a hook system like Drupal, but instead operates on a 



\chapter{BitTorrent}

\section{Overview}
BitTorrent is a protocol for distributing large amounts of data across a network.
Decentralized in design, The BitTorrent protocol allows individuals with limited upstream bandwidth to easily distribute files, minimizing the server load by sharing the bandwidth costs associated with file sharing.

Currently the most popular form of filesharing, BitTorrent has changed the way that people share files on the Internet, making filesharing more democratic and accessible to ordinary users.
According to research conducted by Terry Shaw of CableLabs, and Jim Martin, a computer science professor at Clemson University, 60 percent of American teens equipped with broadband have downloaded audio and video files over peer-to-peer networks. \footnote { \url{http://www.multichannel.com/article/CA6332098.html}}
In the same research paper, Shaw and Martin report that they found that 18\% of all broadband traffic, both upstream and downstream, is used for torrenting .
According to one North American research lab, 55\% of broadband upstream (ie "home outward") is used for torrenting.\footnote{http://www.multichannel.com/article/CA6332098.html}
According to CacheLogic, a British web-analysis company, BitTorrent accounts for only 35 percent of traffic on the Internet, which is still more than all other peer-to-peer programs combined.  
Although researched statistics often vary, by all accounts BitTorrent is responsible for a huge percentage of Internet traffic.\footnote {\url{http://in.tech.yahoo.com/041103/137/2ho4i.html}}

Bit Torrent has been criticized for enabling users to infringe upon copyright laws by sharing files illegally. Some Universities, including WPI, have gone to extreme measures to block access to the Bit Torrent protocol, despite its wide variety of legitimate uses, including the inexpensive distribution of independent media.


\section{Why is Bit Torrent Important?}
%rewriting

\section{The Process}
%Got to figure out how to include pictures. I converted the two images I wanted to include in this section to post script. They're in this folder.
To begin sharing files using the Bit Torrent protocol, users first need to install a client that implements the BitTorrent protocol.
Popular clients include ABC, Azureus, BitTornado, TorrentStorm, and µTorrent. The client can prepare, request, and transfer any part of a torrented file using the protocol.
The original host of the file, called the seeder, creates a torrent file, which contains metadata about the files to be shared, or about the tracker, which is the server that coordinates distribution of the file.
Meta-data stored in this file includes, information about the files to be shared, how the data is divided into logical pieces, and information about the host computer that will be seeding the files. The torrent file also contains a hash checksum of several parts of the file, so that when a peer recieves a piece the client may check to make sure that the piece was downloaded correctly.
Torrent files are very small, usually only a few kilobytes, and can be attached to an email, put on a website, posted on forums, etc.

People who wish to download the files download the appropriate .torrent file, which allows them to connect to the tracker, which is responsible for connecting seeders and peers.
In addition to connecting peers together, some torrent trackers help organize many torrent files into a single website. These websites generally record even more metadata than the data in the torrent files, such as the files title, its author, a website associated with the file, and even descriptions and reviews.
They also provide a the ability to search for a specific file. ChomskyTorrents.org is an example of a public torrent tracker.
Once a user opens a torrent file with their client, they begin downloading pieces of that file.
Users who are currently downloading the file are designated as peers, and the collection of peers downloading the file is referred to as the swarm.
Initially, there is only one seeder in the swarm.
The seeder starts by sends different pieces of the file to as many peers as possible. 
As peers finish downloading pieces of the file, they then share those pieces with the rest of the swarm, distributing the upstream bandwidth load amongst all peers and seeders. 
Once a peer finishes downloading the file, he or she can then leave the file open, and serves as a seeder by continuing to distribute the file to other peers.
The seeder and the peers connect to one another sharing pieces of the file until everyone in the swarm has every piece of the file.

Torrent information can also be derived from a process called torrent scraping, a defacto standard proposed by BitTorrent creator Bram Cohen.\footnote{http://groups.yahoo.com/group/BitTorrent/message/3275, Accessed 01/29/2007}
With scraping, clients can query the state of a torrent that a tracker is managing using the scrape URL. 
The tracker that maintains the scrape URL does so to automate the process of screen scraping\footnote{Screen scraping refers to an algorithm that derives data from a human-readable interface, usually a website} a torrent's statistics page, since there is currently no standard for the layout of these pages. 
Torrent clients may scrape this data by using the announce URL of the torrent file, and finding the last forward slash ("/") in the url. 
If the text immediately following it is the string "announce", then it is assumed that the tracker supports scraping, and the string "scrape" is substituted into the url to find the scraping page. 
Optionally, the client may also request the scrape data using a torrent's info_hash as a paramter, which returns statistics for just that torrent instead of all torrents managed by the tracker. 

After this request, the server responds with a plain text document consisting of a bencoded dictionary, similar to a .torrent file itself. The dictionary contains a list of files, the number of peers who have completed each file, the number of people who have downloaded a torrent, the number of peers who have not yet completed the file, and the internal name. The dictionary may also include unofficial extensions to the scraping standard, known as flags. Some clients use this to specify the minimum number of seconds between scrape requests, error codes, and more.

\section{An Example}
Let's say that a woman in Oaxaca, MX films the Mexican Federal Police attacking teachers on strike for better pay.
She then creates a video file called HumanRightsAbusesInOaxaca-Nov162006.avi. She opens her Bit Torrent client and generates a torrent file.
A new file called, HumanRightsAbusesInOaxaca-Nov162006.avi.torrent is created that logically partitions the original file into several pieces (leaving the original file unchanged), using simple hashes.
She begins seeding the file and sends the torrent file to 100 of her contacts in the United States.
% \includegraphics{oaxaca1.ps}
These 100 people download the torrent file and open it in their Bit Torrent client of choice.
The client now has a list of all the pieces of the file, and can begin requesting them.
The computer in Mexico begins by sending the first piece of the video file to Contact \#1, the second piece of the video file to Contact \#2, the third piece to Contact \#3, and so on.
Once some contact finishing downloading their piece of the video file, he or she can then share that piece with every other peer in the swarm.
Now, the computer in Mexico, the seeder, can concentrate on only sharing pieces of the file that only it has.
% \includegraphics{oaxaca2.ps}
Immediately every client in the swarm, ie every contact in the US, is both uploading and downloading the video file at the same time.
The load is distributed among every client in the swarm.
Furthermore, once the person in Mexico has sent 1 copy of every piece to some person in the swarm, the swarm can finish sharing the file by itself.
Keeping the original seeder in the swarm will speed up the process, but its not necessary as long as every piece of the file exists somewhere in the swarm.
For example, if the original seeder loses her connection to the Internet, the file can still be shared and distributed among the swarm.

\chapter{Current Issues}
Before creating the next incarnation of Broadcast Machine, we need to understand its current shortcomings.
The first step in addressing problems is understanding what they are.
There are a few issues that are often brought up by users and a few more that the developers are concerned about.
There are two larger issues that the developers hold responsible for the majority of Broadcast Machine bugs.
Although the API is thoroughly documented, the data structures have little documentation.
This along with poor application architecture are the two culprits that cause the majority of problems.
These problems are becoming more important to address as Participatory Culture's flagship product Democracy Player grows in popularity and drives the demand for video content management software like Broadcast Machine.
The problems mentioned by users are important to address, but after a while it becomes less efficient to quash bugs than it is to address the cause of these bugs.
We hope that by re-architecting the software we can simulatneously address existing issues and improve on the overall product.
For example, many users would like to adapt their installations to custom environments, but this is made difficult by the current architecture and understanding the current codebase is made difficult by vauge or nonexistent documentation.
With over 20,000 current installs of Broadcast Machine there is certainly a community that would be well served by a rebuilt applictation. \footnote{A search for "Powered by Broadcast Machine" on Google returns upwards of 20,000 results. \url{ http://www.google.com/search?q=\%22Powered+by+Broadcast+Machine\%22}}

Many successful applications, including Broadcast Machine, are architected in such a way that the program is split up into three distinct parts.
This design pattern is most commonly known as "Model-View-Controller (MVC)".
This design methodology separates the application into distinct parts that can be modified without having a detrimental effect on other parts of the program.
The three sections are divided up as follows: The first is the Model which describes how the data in the program is stored, the second is the View which is responsible for how the program interacts with the user and the third is the Controller which bridges the gap between Model and View by responding to events sent by the other components.
Broadcast Machine currently implements this design, albeit poorly.
Unfortunately, the separation between the three segments is often unclear.
    
The majority of the separation problems occur in the 'Model' layer.
Currently Broadcast Machine is structured so that the model is contained in two files, datastore.php and data\_layer.php.
The application uses each of these files to store data and handle the return of data in an understandable manner.
The model can store data in one of two ways, it can insert the data into a MySQL database or it can store the data using a flat-file mechanism.
Datastore.php and data\_layer.php are fantastically intertwined.
Each of the files provides some sort of functionality that the other relies upon.
Through the use of various function hooks, the data layer and the data store are constantly communicating with each other to determine where and how they should store received information.
This intercommunication becomes a problem when the a user or developer changes something in either one.
When changes are made at either place in the program, the other part might fail.
It is hard to be sure what effects changes will have because of this hook system.
Because the hooks are established at runtime, determining which function will be called is often difficult.

The second area in which Broadcast Machine is lacking is documentation.
While there is enough user end documentation to support the existing community there is certainly room for improvement.
The walkthroughs are often only a paragraph long and describe a bare minimum of features available in Broadcast Machine.
The occasional screenshot helps out by showing the user where to navigate, but this is unfortunately in the minority of cases.
Supporting the end user is certainly an issue for a project that wishes to put powerful software in the hands of users, but even more alarming is the sparse developer documentation.
An open-source project like Broadcast Machine can and should leverage the expertise of the community to build a better product and the lack of API documentation and comments in the code only make it more difficult for other developers to improve upon the software.
There are a few files that begin to talk about the data structures used in the program, but it stops short.
While it is certainly a good start, it needs to be cleaned up and completed. There is a certain amount of inline documentation as well, but it is far from complete.
The comments that are there describe why the variables are there, but fail to mention how the a function might work or what effects it has on other parts of the application.
Between architecture and documentation, there are significant portions that Broadcast Machine need improvement.

\chapter{Requirements and Design Decisions}

\section{Architecture}

    Many of Broadcast Machine's current problems stem from its poor architectural implementation.
To prevent these problems from happening in the future, Broadcast Machine must have a carefully planned architecture.
From a design standpoint, a successful architecture has several requirements. 

The application must be designed so that a user with only basic HTML and CSS knowledge can easily customize the website to suit his or her needs.
Ideally, users' site layouts, or "themes", have the potential to look drastically different.
The templates must be abstracted from the functional code, so that users needn't worry about damaging the code or digging deep into its inner workings when modifying the layout.
Users should also have the ability to easily switch between layouts.

Along the same lines, the code must be structured so that it is easily maintainable and extendable by any developer.
The layout of the application should appear logical and concise.
In the event that bugs occur, localizing them to a specific section of code and implementing a fix should be possible without the fix appearing hacked together or thrown in.
Developers should not need to dig through a mountain of code before finding the section that they need to edit.
If features need to be added, the developers should be able to do so while maintaining the same architectural pattern and preserving the structure of the application.
In this sense, a good architecture will encourage good design practices. 

The application must be flexible enough so that it can be re-factored easily.
Functionality should be abstracted and delegated so that major changes to one part of the code do not affect the others.
For example, we may decide later that we would like to use a different type of database.
We should be able to swap out the back end without having to modify the entire application, and without significantly affecting the user experience.
For these reasons, we have chosen a Model-View-Controller design pattern to represent our application.

\section{Compatibility}

The new Broadcast Machine must work across several different platforms.
While impossible to guarantee compatibility with all web server configurations, Broadcast Machine most work on the most common web server setups.
This includes any Apache web server with a minimal amount of installed modules, and most major hosting services (Dreamhost, 1And1, etc).

For this reason, we decided that the program’s front end should be written in PHP, while the back end data layer will be represented by a MySQL database. 
Although Ruby on Rails is great for a Model-View-Controller web application (as it enforces the architecture by its nature, and automatically generates and maintains basic interactions between the layers), it hasn’t been fully adopted by most of the web community. 
Very few hosting services include Ruby in their hosting plan, and setting up Rails manually is a task beyond our target user-base. 
Ruby is not perfect, it too has its draw backs, but in our opinion it would be very well suited for Broadcast Machine. 
However, since it is not well supported we will not use it. 
PHP, while a less than perfect programming language, comes pre-configured with most Apache installs, and is available with most, if not all, web hosting plans. 

Similarly, MySQL is an open-source DBMS (Database Management System) that is perhaps the most widely used SQL (Structured Query Language) implementation, with the exception of enterprise-level applications such as Oracle. 
Like PHP, MySQL comes installed by default with most hosting plans, and setting up a database to be used with our application is a matter of running a script with the correct permissions. 

When choosing our DBMS, we must also predict how the application will scale with databases of varying sizes.
An assumption that the average database will contain less than 1000 records for unique videos is reasonable.
A publisher who produces a show daily would take almost three years to reach 1000 records, and most publishers release videos somewhat less frequently.
Most of the queries on the database will be basic select statements for getting data, and insert or alter statements for adding or modifying video information.
The predicted scale and function of our database would be best suited for a minimalist DBMS such as SQLite, which optimizes access to the data layer for smaller databases that do not need advanced functionality.
Ideally, the program will be flexible enough to use SQLite when available, and require MySQL in all other instances.
Architecting a flexible database controller will allow us to add other DBMS choices as necessary. 

\section{Ease of Use}

    The most obvious requirement for Broadcast Machine is that it be easy to use.
Our target user, people who produce videos, should not need a wealth of technical knowledge in order to deploy and use the program.
Just as we have almost no knowledge of how to shoot or edit a video, we should not expect the user to have any knowledge of PHP, RSS, or any of the technical concepts employed.
Without being privy to any of the inner workings of the program, the user must be able to easily and intuitively publish videos and video "channels" via a simple administrative interface.
Without any information besides their web server login and password, the user should be able to set up Broadcast Machine by dropping the application in their public html folder.
The program should auto-configure itself on the first-run with a few simple clicks, even if the user is completely unaware of how his or her web server is set up.
The application must detect server configurations that may interfere with its behavior, and handle those special cases gracefully.
Another way in which we will keep the install simple, is by using only one install directory.
We will not include any directory structure in the install file, but rather an install script will create any neccesary directories after decompression of the install file.
Sometimes during decompression of files, the directory structure of is lost.
By keeping all install files in one directory and creating a directory structure with an install script will ensure that all the neccesary directories exists and have the proper permissions.

Likewise, viewers with any level of computer proficiency must be able to easily browse and download videos, leave comments and feedback, and subscribe to their favorite channels in Democracy Player (See use cases for more information).
 

\section{Stability}

    Most importantly, the new Broadcast Machine must be stable.
At the very least, it should preserve all of the functionality of its previous incarnation, while containing none of the bugginess or unpredictable behavior.

\section{Features}
% This is just an outline right now. -Greg
There are several requirements for features that Broadcast Machine must include:
 * Automatic generation of RSS feeds
 * Templating system
 * Server-side sharing for BitTorrent
 * Tagging
 * A granular permission system

\chapter{Architecture}

\section{View}

\section{Controller}

\section{Existing Data Model}
%I don't know where else to put this for now... -Greg

\subsection{Instances}
	The instance table was used to prevent two versions of Broadcast Machine from using the same database. In the previous version of Broadcast Machine, if more than one site was using the same database, a warning was displayed on the main page of the administrative interface. The table consists of a hash string of the hostname (id), and a timestamp for when the instance was created (time). 

\subsection{Stats}
	The stats table allowed the user to keep track of the number of user downloads for each video. It contained a unique hash of the filename (id), and an integer for the number of downloads (downloads). The table has a one-to-one relationship with files.

\subsection{BitTorrent}
	The torrents table stored metadata for BitTorrent files. It tracked the hash checksum for the torrent file (info\_hash), the name of the file itself (filename), and a binary file containing the torrent itself. Filename was required to be unique, and the info_hash served as the primary key for the table. In the new schema, this will be expanded to include much more metadata usually associated with torrent trackers.

	The peers table was used to keep track of users who downloaded or were in the process of downloading a file. It contained an info\_hash to designate which torrent file the peer was downloading from, the user's IP address, the port they were using to connect, whether or not they had completed the file (seeder), and a timestamp for when the user connected to the swarm (time). The table was indexed by time, with a combination of ip, port, and the info\_hash server as a primary key (meaning that no two entries could share the same data for all three fields). 

	The combination of these two tables enabled Broadcast Machine to operate as a minimalist BitTorrent tracker.\footnote{for more information on trackers, see the BitTorrent section} Features associated with these tables include BitTorrent file downloads (via the web page view and RSS, as well as server-side seeding of torrents.

\subsection{Channels}

	The channels table was used to store metadata about specific RSS video feeds, or channels. This data was used to generate the channel view and RSS feeds for each channel, which is how most users interact with the application. 
%Show a screenshot of the channel view, perhaps?
It contained a unique integer identifier (ID, the primary key), A text explanation of the channel (description), and integer number for when the channel was made (Created), a text title for the channel (name), fields for URLs of linked icons, libraries, and the channel's main website (Icon, LibraryURL, and WebURL, respectively), a field to designate the publisher (Publisher). In addition to this, it has several tiny int values that served as settings flags, with 0 being false, and the default value, and 1 being true. This includes OpenPublish, RequireLogin, and NotPublic. OpenPublish allowed administrators to designate whether or not non-administrative users were allowed to publish videos to a channel. RequireLogin was used to determine whether or not users must be logged in to view the channel. If NotPublic was set, the channel itself would be hidden from anonymous users.
It also contained CSSURL, which would store a link to an external style sheet to be used in rendering the channel page.

	The channel_options table keeps track of the individual settings for a given channel. Each record in the table contains an integer reference to the channel it refers to (ID). Several boolean flags determined which information about a video would be shown on the channel view: Creator, Description, Filesize, Keywords, Length, Published, Thumbnail, Title, Torrent, URL. There is also a tiny int field called SubscribeOptions, whose default value is 7. This value determines which subscription links will be made available to users (RSS, Democracy, and iTunes, which requires direct URLs to be enabled in the site settings). In this field, RSS is represented by a value of 1, Democracy by a value of 2, and iTunes by a value of 4. Adding together the values of available subscription links determines the field's value. For example, A value of 7 means that all links are available for use, while a value of 1 would mean that only RSS could be used. A value of 6 would mean that iTunes and Democracy subscription links should be made available. 

	The channel_files table records associations between the channels table and the files table (see below). In other words, it allows Broadcast Machine to keep track of which files belong to which channel, which is essential to the channel view and RSS feeds. It contains a reference to the channel in question (channel_id), the hash of the file (hash), and integer timestamp (thetime). The primary key is channel_id and hash, meaning that there can't be more than one record for any channel and file pair.

	The channel_sections table allows channels to be split up into several subsections. From experience, this seems to be widely unused by BM's user base, and is also not implemented in the RSS view. As such, it may be deprecated. The table itself contains an integer reference to the channel the record refers to (channel_id) and the name of the section (Name). The table also shares a one-to-one relationship with the channels table.

	Like channel_files, the section_files table tracks which files are associated with which sections. The table contains a reference to channel_id, a reference to the name of the section, and the hash of the file. The combination of those three fields are a primary key and must be unique.

\subsection{Videos}
	The table for storing video information is the files table. This information is used to render the details page for each individual video. The files table contains a unique integer identifier for each video (ID), an ineger for when the file was created (Created), the name of the file (FileName), the name of the person who created the channel (Creator), a text summary of the file (Description), a title (Title), an optional link to a transcript for the hearing-disabled (transcript), a link to a website for more information(Webpage), an optional donation code (donation_id), boolean flags for Excerpt, Explicit, ignore_mimetype, and External properties, and URL, in case the file was linked to externally. It also contains a link to an image thumnail of the video (Image), name and URL of the license used to distribute the video (LicenseName, LicenseURL), the MIME-type of the file (Mimetype), an integer for the date published (Publishdate), and the date of the video release via three fields: ReleaseDay, ReleaseMonth, and ReleaseYear (all are integers). Also included is a short string called Rights, which is slightly redundant due to the License field. 

	Records of people who have contributed to the making of a video were stored in the file_people table. This allowed administrators to include conprehensive credits for anyone working on the video. The table contained an identifier for which video the credit refers to (ID), their name (name), and what they were credited for (role). The combination of these three values were required to be unique as a primary key.

	"Tags", or categories to classify videos by, were stored in the file_keywords table. This allowed administrators to classify videos by category, so that users could browse videos in that category across many channels. This table contained an ID reference to the video, and then the keyword that the video would be tagged by. Although one video may have had many tags, no video could have two identical tags.

\subsection{Donations}
	The donation table stores information on how users can contribute to the makers of a video. This allowed the generation of donation links to be displayed alongside a video in the video view, as well as from within Democracy and the RSS feed for the channel. Users could use these links to contribute to the makers of the video. Each donation record had a unique ID, an e-mail address (email), a short description (title), and a longer text donation pitch (text). Putting this information in its own table allowed publishers to frequently associate videos with the same donation info, as this info rarely changed. 

	The donation_files table links together donation info with video info. The table conatined the id of the donation info, as well as the hash id of the video (hash). Each video could only be linked to one set of donation information, so id and hash are both primary keys.

\subsection{Users}
	The user table contained information about registered users. This table contained an alias for each user (Username), the user's real name (Name), their encrypted password (Hash), their e-mail address (Email), when they registered (Created), and their permissions information (IsAdmin, IsPending). 

	The newusers table tracked only those users who have not verified their account. This allowed functionality to prevent scripted bots to spam Broadcast Machine installations with open registration, by requiring that all users verify their e-mail address. The table included a filehash, their password (Hash), their e- mail address (email), IsAdmin, and when they created the account (Created).

\subsection{Settings}
	Settings for the website itself was stored in a B-Encoded flat file. This allowed users to customize site security features, as well as which features they wanted to use. This is also where essential information such as database connection settings were stored. These fields include whether or not new user registration was allowed (AllowRegistration), whether or not they required approval (RequireRegApproval), whether or not they needed to verify their account (RequireRegAuth), whether or not users could upload or download anonymously (UploadRegRequired and DownloadRegRequired, respectively), the default channel (DefaultChannel), whether the site has channels that anyone could modify (HasOpenChannels), their current site layout (theme), title of the site, the site description, an image associated with the site, the base url for the site (baseurl), database connection settings (mysql_prefix, mysql_host, mysql_username, mysql_password, mysql_database, and mysql_verified), and BitTorrent sharing settings (Ping, sharing_enable, sharing_auto, sharing_python, sharing_actual_python, minport, maxport). 

\section{Changes to the Database}
	In the new database model, several changes will have to be made in order to normalize the database for increased performance and easier programming. These changes are listed below:

	The stats table has a one-to one relationship with the files table. This means that the two tables can be merged, and tracking the number of downloads can be relegated to a single field in the files table. The channel_options table is also one-to-one with the channels table, so all of its data can be stored in the channels table.

	The instance table can be replaced by a field in the channel settings for the base url of the website. We'll be able to assume that if, when a user goes to set up Broadcase Machine, the base URL has been filled already, then more than one copies of the program are sharing the database. Then, the user will be given a warning and a choice to overwrite this information with the new site.

	A number of fields and tables will become deprecated in the new model. CSSUrl, from the channels table, will be replaced by the new templating system. As features associated with channel_sections are widely unused, they will also be left out of the new schema, but may be added back in later. The files table contains the runtime of the video via three fields, RuntimeHours, RuntimeMinutes, and RuntimeSeconds. These fields will be combined into one runtime field representing the time in seconds, which will be converted into the h:mm:ss format in the file view rather than at the data-layer level.

	The files table is poorly named, since it really stored information on videos, not the files that the videos are encoded in. In the future, it should be possible to have multiple files associated with one video (for hosting multiple formats and resolutions). The name of this table should be changed from files to something more descriptive, such as videos.

	In the users table, the primary key field is Name, which may have caused problems when two people with the same name would attempt to register (e.g. two John Smiths would not be allowed to join at the same time). In the future, the primary key for the table should be username, which should always be unique.

	Site settings will be moved from a B-Encoded file to a table in the database. Since we will be using http-seeding of torrents, some of these settings are expected to change.

\section{New Model}
%This will be changed and updated as the new schema comes along further
%Needs: People should be relational!
Broadcast Machine must keep track of several pieces of information pertaining to its entities (channels, files, etc.).
A comprehensive list of the data follows (entity relationships highlighted in bold):

\subsection{Data associated with Channels}
Channel ID – An arbitrary, unique number to identify the channel and  associate it with other entities
Title – Each Channel has a title, represented by a string
Description - A longer body of text that describes the channel's theme or content
Icon – Reference to the thumbnail image (See below)
Credits – A list of the channel creators and maintainers, or any other people involved.
Donation information – Represented as a snippet of HTML or a simple url.
Website information – A url to link to the channel's main web page.
Tags – 0 or more keywords associated with the channel, used for categorizing and browsing multiple channels.
Permissions – Rules about which users can access or modify the channel

\subsection{Data associated with channel tags:}
Video ID – A reference to the video that the tag describes
Tag name – A short word or phrase to categorize the channel

\subsection{Data associated with Users:}
ID – An arbitrary, unique number to identify the user and associate him/her with other entities
Username – The user's nickname or handle
Password – Self-explanatory
Email Address – Optionally used to verify registration
Permissions – User's access credentials for specific channels, files, and the site in general

\subsection{Data associated with Videos:}
ID – An arbitrary, unique number to identify the user and associate it with other entities
Title – A short amount of text to describe the video
Description - A longer body of text that describes the video's theme or content
Last Modified Date – A time stamp set every time any video information is changed.
Credits – A list of the channel creators and maintainers, or any other people involved.
Icon – Reference to the thumbnail image (See below)
Transcript (optional)– A text-version of the video's content or dialog for the hearing impaired
License/Copyright information – The name of the license associated with the content, and possibly a url to link to the full body of the license
Website url – A link to the video  or publisher's website
Release Date – The date and time the video was released to the public
Publish Date – A timestamp of when the video is made available to the public. note that this is different than release time (For example, a publisher might publish a movie that was released at an earlier time elsewhere).
Running time – The length of the video, in seconds
Adult – A boolean flag used for marking adult content
Donation information – Represented as a snippet of HTML or a simple url.
Tags – 0 or more keywords associated with the channel, used for categorizing and     browsing multiple channels.
Mime-type – The type of media that the file represents
Filename – the url or address on the server where the file is located
Size – the size of the file, in bytes.
Downloads – A running count of the number of users who have downloaded the file
BitTorrent Information (optional) – If the file is a torrent, additional information must be stored (see below)
Permissions – Rules about which users can access or modify the video

\subsection{Data associated with video tags:}
    Video ID – A reference to the video that the tag describes
    Tag name – A short word or phrase to categorize the video

\subsection{Data associated with icons:}
    Icon ID - A unique, autogenerated id number to identify the image
    Icon URL - The address of the icon
    Mime-Type - The type of file that the icon is


\subsection{Data associated with Torrents:}
(To be completed)

(Should we pop the schema itself in here?)

\subsection{Design Decisions}
The current schema departs from the previous data structures in many ways.
Previously, the data layer was represented as a flat-file database.
Although most of the data structures were organized in a normalized, logical way, there were several inconsistencies that needed to be reconciled.

First, several pieces of data were being improperly stored in the database. 
For example, channel and site settings were being stored in the database. 
This information doesn't typically belong in a relational data structure, simply because it does not interact with other entities, nor can it benefit from any of the features of a database. 
Instead, we decided that the data belongs in a simple, transparent configuration file as part of the template system. 
That way, data can be easily read and modified, both by the application and advanced users. 

Channel icons and video icons, are no longer exclusive, and have been combined into a single icon table.
This means that the same icon information can be used by both channels and videos. This will help eliminate duplicate data, and give users more choice in choosing icons.

The new schema also drops several fields and data structures that could be simplified or generated on the fly.
For example, in the previous version, thumbnails were represented as their own entities, because the database stored the mime-type as well as the file address.
Since most, if not all, browsers render images without an explicit mime-type, eliminating this field also allows us to simplify the schema by storing all of the thumbnail information in the channels and video tables themselves.
Similarly, fields like file extension, which can be derived from other data, have been pruned.
We also store information about intellectual property licenses that could be abstracted to its own table.
However, this doesn't provide any significant functional benefits, so the information has been moved to data fields in other tables. 
File data and video data have a one-to-one relationship, so it makes sense to merge them into one table.
This will normalize the table, which will optimize queries and simplify queries that access that data.

\chapter{Utilized Technologies}

\section{Apache}
% 1/18/2007, CJ: Rewrote it to be more concise.
We chose the Apache webserver as our target environment because of its prevalence among low-cost web hosts.
Because the audience we are trying to reach is likely to be running on a tight budget, we are making the assumption that they will choose a low-cost host.
Even outside of this class of service providers, Apache retains market share dominance; so even when users might want to move to a better hosting solution Apache is right there with them. \footnote{From a Netcraft survey spanning Oct. 1995 through Jan. 2007. \url{http://news.netcraft.com/archives/2007/01/05/january_2007_web_server_survey.html}}
Another advantage is that it is very common for PHP and Apache to be installed alongside one another.
With the popularity of the \"L.A.M.P.\" server configuration it is reasonable to make such an assumption.
Apache's support for per-directory configurations via an .htaccess file make it very easy for users and developers to customize the environment without specialized administrator access.
These in-directory configuration files also do not require costly server restarts.
As for Microsoft's IIS webserver, we will make sure that our program runs on the server, but there will be no guarantees that it will be particularly elegant.

\section{PHP}
% 1/18/2007, CJ: Rewrote to be more concise. Perhaps talk about PHP vs. Perl, Python, Ruby
Our team chose to write this application in PHP because it is the one server-side scripting language that is guaranteed to be installed virtually everywhere.
As noted previously, it is often installed alongside Apache and there are many service providers that already have it installed on their servers.
PHP as a language is dynamic and weakly typed with a C-like syntax and a large standard library set that geared towards web development.
Other languages such as Perl, Python, or Ruby might be excellent choices, but they do not command the same percentage of the market share that PHP does.

\subsection{Authentication}
% 1/19/2007, CJ: Added part about user authentication.
Web applications almost always require users to be authenticated and tracked in some way, and PHP provides convenient ways to do both.
Classic username/password authentication can be used to quickly verify the users identity and through the user of built in session\_* functions in PHP we can easily create persistent user sessions.
More details on how this functionality will be used can be found in the implementation section.

\section{SQL}
% 1/18/2007, CJ: Nassar suggested that there should be some mention of object vs. relational databases here. I don't think there's much to talk about!
To store all of the information about the channels, videos and settings in Broadcast Machine, we decided that a relational database would be best. 
As opposed to previous releases, this version will only have SQL database support.
We figure that since the last release SQL databases have become commonplace.
PHP itself is proof of this, as it easily interfaces with MySQL and SQLite.
We feel that a database lets us store and retrieve data in the most scalable and efficient way possible without sacrificing the overall goals of the program.
It is important to note that the database setup will be automated for the user like it is with weblog package WordPress.
This automation helps us work around the problem of the user having to configure a complex database. (A great concern for us! Many of our users might not be very computer savvy.)

\section{URL Rewriting (mod_rewrite)}
% 1/22/2007, CJ: Rewrote the section about URL rewriting.
In the past few years, URL's have become more and more difficult to understand as web applications have come to dominate.
URL's were designed to be easier to remember than IP addresses, but the've shown they can be just as tough to remember.
One way to make URL's easy to remember is to rewrite them through the use of the Apache module mod_rewrite.
This module rewrites making the server pretend that a file exists.
When it receives a request for a URL it modifies it based on pre-determined rules that can be set by the user.
These settings can be configured on a per-directory basis by placing the rewrite rules in the .htaccess file.
URL rewriting also serves another purpose.
Apple's iTunes will 
This feature is also necessary to make sure that iTunes can subscribe to feeds produced by Broadcast Machine.
iTunes requires that the file to be downloaded ends as a file extension that it likes.
Unfortunately those file extensions are not usually webpages, they are usually MP3 instead of PHP.
It will only download your MP3 if it looks like \url{http://www.foobar.com/index.mp3?show=4.mp3} versus the traditional \url{http://www.foobar.com/index.mp3?show=4.mp3}. \footnote{\url{http://www.apple.com/itunes/store/podcaststechspecs.html}}
Not convenient, but necessary given the popularity of iTunes and the demand for compatible content.

\section{BitTorrent}
% 1/18/2007, CJ: Outlined the topics that need to be covered.
% * Metainfo (.torrent) Files
%  - Support for bencoding strings.
% * Tracker
%  - http://www.bittorrent.org/protocol.html
% * HTTP Seeder
%  - http://www.bittornado.com/docs/webseed-spec.txt
\subsection{Metainfo (.torrent) Files}
In order to distribute files via using the BitTorrent protocol the server must go through three steps.
The first is to generate a .torrent file that describes the file to be downloaded.
This file is \"bencoded\", a format that is unaffected by endianness on various platforms and makes the file well suited for any computer. (See below for more on Bencoding.)
The encoded information is a dictionary (or associative array) of several values.
There are two keys in the file, the first is called 'announce' and is associated with the URL of the tracker.
The second is another dictionary called 'info' which contains a few more keys.
Key one is 'name' which is a suggested filename for the file, second is 'piece length' which is the length in bytes of each piece the file is split into.
Third is 'pieces' which are the number of pieces the file was split into, fourth is 'length' which is the total file size in bytes, and last is 'path' which is \"a list of strings corresponding to subdirectory names\".

\subsection{Trackers}
The second step is to begin running a tracker.
Trackers is a central point of contact for all of the people sharing a particular file.
When a client contacts the tracker they send their information via an HTTP GET message that is formed using ordinary CGI methods.
This means that each parameter is sent by using \"?parameter=value\" sequences that are appended to the announce URL.
Some of the parameters include:
\begin{description}
	\item[info_hash] A 20-byte SHA1 hash of the value of the info key that was sent in the torrent file.
	\item[peer_id] A 20-byte string used to identify the client.
	\item[port] The port number that the client is listening on.
	\item[uploaded] The total number of bytes uploaded.
	\item[downloaded] The total number of bytes downloaded.
	\item[left] Number of bytes the client has left to download.
	\item[compact] Indicates that the client accepts 'compact' responses. If this is set, the tracker should respond with a set of six byte strings that contain four bytes of network address and two bytes of the listening port.
	\item[event] Three 'events' can be sent to the tracker. One is 'started' which tells that the client has begun downloading, the second is 'stopped' which must be sent when the client shuts down gracefully, and the third is 'completed' which should be sent when the client finishes downloading the file.
\end{description}
The tracker responds to these events with a document with Mimetype \"text/plain\" that contains a bencoded dictionary with the following values.
\begin{description}
	\item[failure reason] If this key is present, then no other keys can be. The value should be a (written) message explaining why the request couldn't be completed.
	\item[warning message] Like 'failure reason' except the request is still processed.
	\item[interval] The number of seconds the client should wait between regular requests to the tracker.
	\item[min interval] The minimum amount of time a client must wait between requests.
	\item[tracker id] A string that the client should send back when it announces.
	\item[complete] The number of people who have finished downloading the file.
	\item[incomplete] Number of people downloading but have not finished.
	\item[peers] Contains a list of dictionaries describing the peers, each dictionary should have three keys. The first is 'peer id' which is the peer's self-selected id number, the second is the peer's IP address and the third is the port on which the peer is listening.
As it is now, these are the fields that are absolutely required for a BitTorrent tracker, but there are a few unofficial extensions to the protocol that might be interesting to look at in the future. \footnote{\url{http://wiki.theory.org/BitTorrentSpecification}}

\subsection{Web Seeding}
When a user wants to distribute a file via BitTorrent, they need to stay online using their client 'seeding' the file to others.
Web Seeding begins to alleviate this problem by using an HTTP server for seeding.
The first thing that this extension specifies is that there should be a key added to the metainfo file that is called \"httpseeds\" and contains a list of URLs where data can be downloaded from over HTTP.
The client then takes this base URL and appends information to it to specify which parts of the file it would like to read.
The request is then requested via HTTP GET and fielded by the server.
In response, the server should send HTTP status 200 for 'OK' and the requested data in binary, or an HTTP status 503 for 'Service Temporarily Unavailable'. 
The protocol itself is relatively simple, but it leaves the door wide open for clients to make to many requests and bog down the server.
To address this problem it is imperative that the seeding portion have some method of controlling how much upload bandwidth is used.


\section{XML and RSS}
% 1/18/2007, CJ: OUtlined the topics that need to be covered.
% * XML
%  - History
% * RSS
%  - History
%  - Various Versions
%  - Why 2.0?
%  - Basic RSS Structure Example
%  - HTTP Caching
%  - Yahoo! Media RSS Extensions
%   > Specified Tags
%  - Apple iTunes Podcasting Specification
%   > Specified Tags

%\section{Mimetypes}
% 1/22/2007, CJ: Do we still need a section on Mimetypes?

\section{Smarty}
We decided to use the Smarty templating system because of its 

\section{XHTML and CSS}
% 1/25/2007, More needs to be added about CSS.
XHTML, or the Extensible HyperText Markup Language, is a markup language that allows the same amount of versatility as HTML, but with a stricter syntax. 
HTML is an application of the Standard Generalized Markup Language (SGML), a very versatile markup language, whereas XHTML is an application of XML, a more restrictive subset of SGML. 
XHTML is a reformulation of HTML in XML, so in many ways its a cross between XML and HTML. 
Because XHTML code needs to be well-formed and syntactically correct, XHTML documents allow for automated processing to be performed using a standard XML library. 
This is unlike HTML, which due to its leniency requires a relatively complex and usually custom parser. 

XHTML 1.0 became an official World Wide Web Consortium (W3C) recommendation on January 2000. 


\chapter{Development}

\section{Architecture}
%This probably isn't too latex friendly yet - Greg
Active development began with discussions of how to best architect Broadcast Machine with a defined set of features:
  * Unit tests for all of the implemented functionality
  * A web based setup process
  * Creating channels
  * Browsing Channels
  * Managing channels
  * Creating video items from links
  * Creating video items from uploaded files
  * Browsing videos in a channel
  * Managing video items
  * Video RSS in all the forms curently available
  * Subscribe via Democracy link
  * User Authentication and permissions
  * Ability to import data from an existing Broadcast Machine
  * BitTorrent tracking
  * BitTorrent seeding via HTTP seeding support

\subsection{Flow}
We then decided on a logical process for how the application would handle requests for information. First, the application would receive a URL, POST parameters, and cookie information from the web server. URLs will be typically received from mod_rewrite in the form of http://baseurl.com/controller/action. The action field may also reference another controler, in which case it would be followed by another parameter for the action that controller should take. For example, say a person runs a Broadcast Machine install on http://foobar.com. If a user would like to browse all videos on the site by a specific category, such as "dogs", he or she would go to www.foobar.com/tags/dogs/. In this case, /tags is a reference to the tag controller, which is responsible for getting all videos that contain that tag. The parameter to be passed to the video controller is dogs, which means that only videos containing the dogs tag will be returned. 

After the controller generates an associated array of data (which may contain other arrays), it passed this information to the view layer, or template. The template uses this information to fill in an XHTML or RSS page, and sets the mime type (in the case of linking to files), and renders the user interface.

\section{Program API}
Next, we considered the program API, or the way in which the actual code and data would be laid out. This affects not only the program itself, but also how developers would go about adding new features and modifying existing ones.

\section{Controllers and Views}
After coming up with an acceptable API, our next task was to come up with a list of views, and delegate responsibilities for getting the data necessary to render those views to the appropriate controller.

\subsection{Front Page "/"}
The front page is found at the top directory of the Broadcast Machine install ("/"). This page lists all of the viewable channels. If a user is logged in as an administrator, it also provides links to add, edit, or remove that channel, as well as subscribe links for Democracy Player, RSS, and iTunes (depending on the site settings). The controller responsible for getting the information about each channel is aptly named the frontpage controller.

\subsection{Channel View "/channelname"}
The channel view lists all videos in a channel, and is accessed by going to a URL-safe truncation of that channel's name. This view calls the channel controller to retrieve information about every video in the channel, and then inserts that information into the template. The view also displays channel statistics, subscription links, and has buttons to edit, delete, or add new videos if you are logged in as an administrator, which correspond to appropriate video controller actions. Administrators also have the ability to see links to delete the entire channel, or edit it.

Adding a video to a channel is handled by the "add" action of the channel controller (/channelname/add). When adding a video, users will be able to enter detailed metadata about the video, and either link directly to the file or upload it directly to the server, albeit with restrictions\footnote{PHP has a maximum file size for uploading that depends on the server configuration}. Users will also be given the option to upload the file on their own via FTP, and have Broadcast Machine detect it later. Similar to adding videos, there will also be appropriate channel controller actions for removing the channel (/channelname/remove) and editing it (/channel/edit)

\subsection{Video view "/channelname/videoname" & "/video/videoname"}
The video view displays all of the relevant information about an individual video, including its meta-data and download statistics. It will optionally display a video preview of the file instead of a static thumbnail image. The view will also generate a link to download the entire file.

\subsection{User Page "/users/"}
The user
\section{Model Schema}

\end{document}

